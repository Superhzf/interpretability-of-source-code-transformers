\n 
# \n 
from horizon import tabs \n 
class NetworkProfileTab ( tabs . Tab ) : \n 
slug = "network_profile" \n 
template_name = \n 
def get_context_data ( self , request ) : \n 
~~~ return None \n 
~~ ~~ class PolicyProfileTab ( tabs . Tab ) : \n 
slug = "policy_profile" \n 
preload = False \n 
~~ class IndexTabs ( tabs . TabGroup ) : \n 
~~~ slug = "indextabs" \n 
tabs = ( NetworkProfileTab , PolicyProfileTab ) \n 
import weakref \n 
from eventlet import corolocal \n 
class WeakLocal ( corolocal . local ) : \n 
~~~ def __getattribute__ ( self , attr ) : \n 
~~~ rval = corolocal . local . __getattribute__ ( self , attr ) \n 
if rval : \n 
~~~ rval = rval ( ) \n 
~~ return rval \n 
~~ def __setattr__ ( self , attr , value ) : \n 
~~~ value = weakref . ref ( value ) \n 
return corolocal . local . __setattr__ ( self , attr , value ) \n 
~~ ~~ store = WeakLocal ( ) \n 
weak_store = WeakLocal ( ) \n 
strong_store = corolocal . local \n 
import eventlet \n 
eventlet . monkey_patch ( ) \n 
import contextlib \n 
import sys \n 
from oslo . config import cfg \n 
from openstack_dashboard . openstack . common import log as logging \n 
from openstack_dashboard . openstack . common import rpc \n 
from openstack_dashboard . openstack . common . rpc import impl_zmq \n 
CONF = cfg . CONF \n 
CONF . register_opts ( rpc . rpc_opts ) \n 
CONF . register_opts ( impl_zmq . zmq_opts ) \n 
def main ( ) : \n 
~~~ CONF ( sys . argv [ 1 : ] , project = ) \n 
logging . setup ( "oslo" ) \n 
with contextlib . closing ( impl_zmq . ZmqProxy ( CONF ) ) as reactor : \n 
~~~ reactor . consume_in_thread ( ) \n 
reactor . wait ( ) \n 
~~ ~~ from enum import IntEnum \n 
from . component import Component \n 
from . object import field \n 
class ReflectionProbeUsage ( IntEnum ) : \n 
~~~ Off = 0 \n 
BlendProbes = 1 \n 
BlendProbesAndSkybox = 2 \n 
Simple = 3 \n 
~~ class ShadowCastingMode ( IntEnum ) : \n 
On = 1 \n 
TwoSided = 2 \n 
ShadowsOnly = 3 \n 
~~ class Renderer ( Component ) : \n 
~~~ enabled = field ( "m_Enabled" , bool ) \n 
lightmap_index = field ( "m_LightmapIndex" ) \n 
materials = field ( "m_Materials" ) \n 
probe_anchor = field ( "m_ProbeAnchor" ) \n 
receive_shadows = field ( "m_ReceiveShadows" , bool ) \n 
reflection_probe_usage = field ( "m_ReflectionProbeUsage" , ReflectionProbeUsage ) \n 
shadow_casting_mode = field ( "m_CastShadows" , ShadowCastingMode ) \n 
sorting_layer_id = field ( "m_SortingLayerID" ) \n 
sorting_order = field ( "m_SortingOrder" ) \n 
use_light_probes = field ( "m_UseLightProbes" , bool ) \n 
lightmap_index_dynamic = field ( "m_LightmapIndexDynamic" ) \n 
lightmap_tiling_offset = field ( "m_LightmapTilingOffset" ) \n 
lightmap_tiling_offset_dynamic = field ( "m_LightmapTilingOffsetDynamic" ) \n 
static_batch_root = field ( "m_StaticBatchRoot" ) \n 
subset_indices = field ( "m_SubsetIndices" ) \n 
@ property \n 
def material ( self ) : \n 
~~~ return self . materials [ 0 ] \n 
~~ ~~ class ParticleSystemRenderMode ( IntEnum ) : \n 
~~~ Billboard = 0 \n 
Stretch = 1 \n 
HorizontalBillboard = 2 \n 
VerticalBillboard = 3 \n 
Mesh = 4 \n 
~~ class ParticleSystemSortMode ( IntEnum ) : \n 
~~~ None_ = 0 \n 
Distance = 1 \n 
OldestInFront = 2 \n 
YoungestInFront = 3 \n 
~~ class MeshRenderer ( Component ) : \n 
~~~ pass \n 
~~ class ParticleRenderer ( Renderer ) : \n 
~~~ camera_velocity_scale = field ( "m_CameraVelocityScale" ) \n 
length_scale = field ( "m_LengthScale" ) \n 
max_particle_size = field ( "m_MaxParticleSize" ) \n 
velocity_scale = field ( "m_VelocityScale" ) \n 
stretch_particles = field ( "m_StretchParticles" ) \n 
~~ class ParticleSystemRenderer ( Renderer ) : \n 
mesh = field ( "m_Mesh" ) \n 
mesh1 = field ( "m_Mesh1" ) \n 
mesh2 = field ( "m_Mesh2" ) \n 
mesh3 = field ( "m_Mesh3" ) \n 
normal_direction = field ( "m_NormalDirection" ) \n 
render_mode = field ( "m_RenderMode" , ParticleSystemRenderMode ) \n 
sort_mode = field ( "m_SortMode" , ParticleSystemSortMode ) \n 
sorting_fudge = field ( "m_SortingFudge" ) \n 
~~ from ConfigParser import * \n 
from StringIO import * \n 
from Log import Log \n 
import datetime \n 
class Config : \n 
~~~ @ staticmethod \n 
def LoadConfig ( ) : \n 
~~~ Config . parser = ConfigParser ( ) \n 
try : \n 
~~~ sconff = open ( CONFIG_FILE , "r" ) \n 
~~ except : \n 
return \n 
~~ sconf = StringIO ( ) \n 
sconf . write ( "[sysconf]\\n" ) \n 
sconf . write ( sconff . read ( ) ) \n 
sconf . seek ( 0 ) \n 
Config . parser . readfp ( sconf ) \n 
sconff . close ( ) \n 
sconf . close ( ) \n 
~~ @ staticmethod \n 
def GetBoardsFile ( ) : \n 
~~~ return BOARDS_FILE \n 
def GetInt ( name , defval ) : \n 
~~~ if ( Config . parser . has_option ( , name ) ) : \n 
~~~ return Config . parser . getint ( , name ) \n 
~~ else : \n 
~~~ return defval \n 
~~ ~~ @ staticmethod \n 
def GetString ( name , defval ) : \n 
~~~ val = Config . parser . get ( , name ) \n 
if ( val [ 0 ] == \'"\' and val . endswith ( \'"\' ) ) : \n 
~~~ val = val [ 1 : - 1 ] \n 
~~ return val . decode ( ) \n 
~~ ~~ ~~ BBS_ROOT = \n 
BBS_XMPP_CERT_FILE = BBS_ROOT + "xmpp.crt" \n 
BBS_XMPP_KEY_FILE = BBS_ROOT + "xmpp.key" \n 
BOARDS_FILE = BBS_ROOT + \n 
STRLEN = 80 \n 
ARTICLE_TITLE_LEN = 60 \n 
BM_LEN = 60 \n 
MAXBOARD = 400 \n 
CONFIG_FILE = BBS_ROOT + \n 
FILENAME_LEN = 20 \n 
OWNER_LEN = 30 \n 
SESSIONID_LEN = 32 \n 
REFRESH_TOKEN_LEN = 128 \n 
NAMELEN = 40 \n 
IDLEN = 12 \n 
MD5PASSLEN = 16 \n 
OLDPASSLEN = 14 \n 
MOBILE_NUMBER_LEN = 17 \n 
MAXCLUB = 128 \n 
MAXUSERS = 20000 \n 
MAX_MSG_SIZE = 1024 \n 
MAXFRIENDS = 400 \n 
MAXMESSAGE = 5 \n 
MAXSIGLINES = 6 \n 
IPLEN = 16 \n 
DEFAULTBOARD = "sysop" \n 
BLESS_BOARD = "happy_birthday" \n 
QUOTED_LINES = 10 \n 
MAXACTIVE = 8000 \n 
USHM_SIZE = MAXACTIVE + 10 \n 
UTMP_HASHSIZE = USHM_SIZE * 4 \n 
UCACHE_SEMLOCK = 0 \n 
LEN_FRIEND_EXP = 15 \n 
SESSION_TIMEOUT = datetime . timedelta ( 30 ) \n 
SESSION_TIMEOUT_SECONDS = 86400 * 30 \n 
XMPP_IDLE_TIME = 300 \n 
XMPP_LONG_IDLE_TIME = 1800 \n 
XMPP_UPDATE_TIME_INTERVAL = 10 \n 
XMPP_PING_TIME_INTERVAL = 60 \n 
PUBLIC_SHMKEY = 3700 \n 
MAX_ATTACHSIZE = 20 * 1024 * 1024 \n 
BMDEL_DECREASE = True \n 
SYSMAIL_BOARD = "sysmail" \n 
ADD_EDITMARK = True \n 
SEARCH_COUNT_LIMIT = 20 \n 
MAIL_SIZE_LIMIT = - 1 \n 
SEC_DELETED_OLDHOME = 3600 * 24 * 3 \n 
SELF_INTRO_MAX_LEN = 800 \n 
import re \n 
import os \n 
import stat \n 
import json \n 
import struct \n 
import time \n 
import Config \n 
import Board \n 
import Post \n 
import BoardManager \n 
from Util import Util \n 
from errors import * \n 
DEFAULT_DIGEST_LIST_COUNT = 20 \n 
class DigestItem : \n 
~~~ def __init__ ( self , basepath ) : \n 
~~~ self . basepath = basepath \n 
self . title = \n 
self . host = \n 
self . port = 0 \n 
self . attachpos = 0 \n 
self . fname = \n 
self . mtitle = \n 
self . items = [ ] \n 
self . update_time = 0 \n 
self . id = 0 \n 
self . sysop_only = 0 \n 
self . bms_only = 0 \n 
self . zixia_only = 0 \n 
~~ def IsDir ( self ) : \n 
~~~ try : \n 
~~~ st = os . stat ( self . realpath ( ) ) \n 
return stat . S_ISDIR ( st . st_mode ) \n 
~~~ return False \n 
~~ ~~ def IsFile ( self ) : \n 
return stat . S_ISREG ( st . st_mode ) \n 
~~ ~~ def GetModTime ( self ) : \n 
mtime = st . st_mtime \n 
~~~ mtime = time . time ( ) \n 
~~ return mtime \n 
~~ def names_path ( self ) : \n 
~~~ return "%s/.Names" % self . realpath ( ) \n 
~~ def realpath ( self ) : \n 
~~~ return "%s/%s" % ( Config . BBS_ROOT , self . path ( ) ) \n 
~~ def path ( self ) : \n 
~~~ if ( self . fname ) : \n 
~~~ return "%s/%s" % ( self . basepath , self . fname ) \n 
~~~ return self . basepath \n 
~~ ~~ def CheckUpdate ( self ) : \n 
~~~ stat = os . stat ( self . names_path ( ) ) \n 
if ( stat . st_mtime > self . update_time ) : \n 
~~~ self . LoadNames ( ) \n 
~~ ~~ except : \n 
~~ return True \n 
~~ def LoadNames ( self ) : \n 
~~~ f = open ( self . names_path ( ) , "r" ) \n 
~~ except IOError : \n 
~~~ return 0 \n 
~~ stat = os . fstat ( f . fileno ( ) ) \n 
self . update_time = stat . st_mtime \n 
item = DigestItem ( self . path ( ) ) \n 
hostname = \n 
_id = 0 \n 
bms_only = 0 \n 
sysop_only = 0 \n 
zixia_only = 0 \n 
while ( True ) : \n 
~~~ line = f . readline ( ) \n 
if ( line == "" ) : break \n 
npos = line . find ( "\\n" ) \n 
if ( npos != - 1 ) : line = line [ : npos ] \n 
if ( line [ : 1 ] == ) : \n 
~~~ if ( not self . mtitle ) : \n 
~~~ self . mtitle = line [ 8 : ] \n 
~~ ~~ ~~ result = re . match ( , line ) \n 
if ( result ) : \n 
~~~ key = result . group ( 1 ) \n 
value = result . group ( 2 ) \n 
if ( key == "Name" ) : \n 
~~~ item . title = value \n 
item . attachpos = 0 \n 
~~ elif ( key == "Path" ) : \n 
~~~ if ( value [ : 2 ] == "~/" ) : \n 
~~~ item . fname = value [ 2 : ] \n 
~~~ item . fname = value \n 
~~ if ( item . fname . find ( ".." ) != - 1 ) : \n 
~~~ continue \n 
~~~ bms_only += 1 \n 
~~~ sysop_only += 1 \n 
~~~ zixia_only += 1 \n 
~~ if ( item . fname . find ( "!@#$%" ) != - 1 ) : \n 
~~~ parts = re . split ( , item . fname ) \n 
newparts = [ ] \n 
for part in parts : \n 
~~~ if ( part ) : \n 
~~~ newparts += [ part ] \n 
~~ ~~ hostname = newparts [ 0 ] \n 
item . fname = newparts [ 1 ] \n 
~~~ item . port = int ( newparts [ 2 ] ) \n 
~~~ item . port = 0 \n 
~~ ~~ item . id = _id \n 
_id += 1 \n 
item . bms_only = bms_only \n 
item . sysop_only = sysop_only \n 
item . zixia_only = zixia_only \n 
item . host = hostname \n 
self . items += [ item ] \n 
~~ elif ( key == "Host" ) : \n 
~~~ hostname = value \n 
~~ elif ( key == "Port" ) : \n 
~~~ item . port = int ( value ) \n 
~~ ~~ elif ( key == "Attach" ) : \n 
~~~ item . attachpos = int ( value ) \n 
~~~ item . attachpos = 0 \n 
~~ ~~ ~~ ~~ f . close ( ) \n 
return 1 \n 
~~ def GetItem ( self , user , route , has_perm = False , need_perm = False ) : \n 
~~~ self . CheckUpdate ( ) \n 
if ( self . mtitle . find ( "(BM:" ) != - 1 ) : \n 
~~~ if ( Board . Board . IsBM ( user , self . mtitle [ 4 : ] , ) or user . IsSysop ( ) ) : \n 
~~~ has_perm = True \n 
~~ elif ( need_perm and not has_perm ) : \n 
~~ if ( len ( route ) == 0 ) : \n 
~~~ return self \n 
~~ target = route [ 0 ] - 1 \n 
_id = target \n 
if ( _id >= len ( self . items ) ) : \n 
~~ while ( self . items [ _id ] . EffectiveId ( user ) < target ) : \n 
~~~ _id += 1 \n 
~~ ~~ item = self . items [ _id ] \n 
item . mtitle = item . title \n 
if ( len ( route ) == 1 ) : \n 
~~~ return item \n 
~~~ if ( item . IsDir ( ) ) : \n 
~~~ if ( not item . CheckUpdate ( ) ) : \n 
~~ return item . GetItem ( user , route [ 1 : ] , has_perm , need_perm ) \n 
~~ ~~ ~~ def GetRange ( self , user , route , start , end , has_perm = False , need_perm = False ) : \n 
firstitem = self . GetItem ( user , route + [ start ] , has_perm , need_perm ) \n 
if ( not firstitem ) : \n 
~~~ return [ ] \n 
~~ parent = self . GetItem ( user , route , has_perm , need_perm ) \n 
if ( not parent ) : \n 
~~ if ( not parent . IsDir ( ) ) : \n 
~~ result = [ ] \n 
_id = start - 1 \n 
for i in range ( start , end + 1 ) : \n 
~~~ target = i - 1 \n 
if ( _id >= len ( parent . items ) ) : \n 
~~ while ( parent . items [ _id ] . EffectiveId ( user ) < target ) : \n 
~~~ return result \n 
~~ ~~ item = parent . items [ _id ] \n 
result += [ item ] \n 
~~ return result \n 
~~ def EffectiveId ( self , user ) : \n 
~~~ _id = self . id \n 
if ( user . IsSysop ( ) ) : \n 
~~~ return _id \n 
~~ if ( not user . IsSysop ( ) ) : \n 
~~~ _id -= self . sysop_only \n 
~~ if ( not user . IsBM ( ) ) : \n 
~~~ _id -= self . bms_only \n 
~~ if ( not user . IsSECANC ( ) ) : \n 
~~~ _id -= self . zixia_only \n 
~~ return _id \n 
~~ def GetInfo ( self ) : \n 
~~~ info = { } \n 
info [ ] = Util . gbkDec ( self . mtitle ) \n 
info [ ] = Util . gbkDec ( self . title ) \n 
info [ ] = self . attachpos \n 
if ( self . host != ) : \n 
~~~ info [ ] = self . host \n 
info [ ] = self . port \n 
info [ ] = \n 
~~ elif ( self . IsDir ( ) ) : \n 
~~~ info [ ] = \n 
~~ elif ( self . IsFile ( ) ) : \n 
~~ info [ ] = int ( self . GetModTime ( ) ) \n 
return info \n 
~~ def GetInfoForUser ( self , user ) : \n 
~~~ info = self . GetInfo ( ) \n 
info [ ] = self . EffectiveId ( user ) + 1 \n 
~~ def GetAttachLink ( self , session ) : \n 
filename = \n 
for i in range ( 2 ) : \n 
~~~ filename += "%0x" % struct . unpack ( , _hash [ i * 4 : ( i + 1 ) * 4 ] ) \n 
~~ link = "http://%s/bbscon.php?b=xattach&f=%s" % ( session . GetMirror ( Config . Config . GetInt ( , 80 ) ) , filename ) \n 
linkfile = "%s/boards/xattach/%s" % ( Config . BBS_ROOT , filename ) \n 
target = "../../%s" % self . path ( ) \n 
~~~ os . symlink ( target , linkfile ) \n 
~~ return link \n 
~~ ~~ class Digest : \n 
~~~ root = DigestItem ( "0Announce" ) \n 
def __init__ ( self , board , path ) : \n 
~~~ self . board = board \n 
self . path = path \n 
self . root = DigestItem ( self . path ) \n 
def GET ( svc , session , params , action ) : \n 
~~~ if ( session is None ) : raise Unauthorized ( ) \n 
user = session . GetUser ( ) \n 
boardname = svc . get_str ( params , , ) \n 
if ( boardname ) : \n 
~~~ board = BoardManager . BoardManager . GetBoard ( boardname ) \n 
if ( board is None ) : raise NotFound ( % boardname ) \n 
if ( not board . CheckReadPerm ( user ) ) : \n 
~~~ raise NoPerm ( ) \n 
~~ basenode = board . digest . root \n 
has_perm = user . IsDigestMgr ( ) or user . IsSysop ( ) or user . IsSuperBM ( ) \n 
~~~ basenode = Digest . root \n 
has_perm = user . IsDigestMgr ( ) \n 
~~ if ( action == "list" ) : \n 
~~~ route = svc . get_str ( params , ) \n 
start = svc . get_int ( params , , 1 ) \n 
end = svc . get_int ( params , , start + DEFAULT_DIGEST_LIST_COUNT - 1 ) \n 
Digest . List ( svc , basenode , route , start , end , session , has_perm ) \n 
~~ elif ( action == "view" ) : \n 
start = svc . get_int ( params , , 0 ) \n 
count = svc . get_int ( params , , 0 ) \n 
Digest . View ( svc , basenode , route , session , has_perm , start , count ) \n 
~~~ raise WrongArgs ( % action ) \n 
def ParseRoute ( route ) : \n 
~~~ ret = [ ] \n 
items = re . split ( , route ) \n 
items = items [ 1 : ] \n 
for item in items : \n 
~~~ ret += [ int ( item ) ] \n 
~~~ raise WrongArgs ( % item ) \n 
~~ ~~ return ret \n 
def List ( svc , basenode , route , start , end , session , has_perm ) : \n 
~~~ route_array = Digest . ParseRoute ( route ) \n 
parent = basenode . GetItem ( session . GetUser ( ) , route_array , has_perm ) \n 
~~~ raise WrongArgs ( % route ) \n 
~~ items = basenode . GetRange ( session . GetUser ( ) , route_array , start , end , has_perm ) \n 
result = { } \n 
result [ ] = parent . GetInfoForUser ( session . GetUser ( ) ) \n 
result [ ] = len ( items ) \n 
result_list = [ ] \n 
~~~ result_list += [ item . GetInfoForUser ( session . GetUser ( ) ) ] \n 
~~ result [ ] = result_list \n 
svc . writedata ( json . dumps ( result ) ) \n 
def View ( svc , basenode , route , session , has_perm , start , count ) : \n 
item = basenode . GetItem ( session . GetUser ( ) , route_array , has_perm ) \n 
if ( not item ) : \n 
~~ if ( not item . IsFile ( ) ) : \n 
~~ result = { } \n 
result [ ] = item . GetInfoForUser ( session . GetUser ( ) ) \n 
postinfo = Post . Post ( item . realpath ( ) , None ) \n 
( result [ ] , result [ ] ) = postinfo . GetContent ( start , count ) \n 
attachlist = postinfo . GetAttachListByType ( ) \n 
result [ ] = attachlist [ 0 ] \n 
result [ ] = attachlist [ 1 ] \n 
if ( attachlist [ 0 ] or attachlist [ 1 ] ) : \n 
~~~ result [ ] = item . GetAttachLink ( session ) \n 
~~ svc . writedata ( json . dumps ( result ) ) \n 
~~ ~~ import time \n 
import UserManager \n 
import UserInfo \n 
from Session import Session \n 
import UCache \n 
import MsgBox \n 
import xmpp \n 
import modes \n 
import Util \n 
import traceback \n 
from xmpp . features import NoRoute \n 
__disco_info_ns__ = \n 
__disco_items_ns__ = \n 
__vcard_ns__ = \n 
STEAL_AFTER_SEEN = 3 \n 
def elem_to_str ( elem ) : \n 
~~ class XMPPServer ( xmpp . Plugin ) : \n 
def __init__ ( self , rosters , host ) : \n 
~~~ self . probed = False \n 
self . _closed = False \n 
self . rosters = rosters \n 
self . _session = None \n 
self . rosters . set_resources ( self . get_resources ( ) ) \n 
self . _fixedjid = UCache . UCache . formalize_jid ( unicode ( self . authJID ) ) \n 
self . _userid = self . _fixedjid . partition ( ) [ 0 ] . encode ( "gbk" ) \n 
if ( not self . rosters . allow_login ( self . authJID . bare ) ) : \n 
self . stream_error ( , ) \n 
if self . authJID . resource [ : - 8 ] != "Resource" and len ( self . authJID . resource ) > 8 : \n 
~~~ routes = self . routes ( self . authJID . bare ) \n 
for route in routes : \n 
~~~ jid = route [ 0 ] \n 
if jid . resource [ : - 8 ] == self . authJID . resource [ : - 8 ] : \n 
~~~ if jid . resource != self . authJID . resource : \n 
route [ 1 ] . stream_error ( , ) \n 
~~ ~~ else : \n 
~~ ~~ ~~ except NoRoute : \n 
~~ self . _user = UserManager . UserManager . LoadUser ( self . _userid ) \n 
if ( self . _user == None ) : \n 
~~ self . _peer_addr = self . getpeername ( ) \n 
self . _session = Session ( self . _user , self . _peer_addr [ 0 ] ) \n 
self . _session . RecordLogin ( ) \n 
self . _userinfo = self . _session . Register ( ) \n 
self . _loginid = self . _session . utmpent \n 
self . _hostname = host \n 
self . bind ( xmpp . ReceivedCloseStream , self . recv_close ) \n 
self . bind ( xmpp . StreamClosed , self . stream_closed ) \n 
self . bind ( xmpp . SentCloseStream , self . sent_close ) \n 
self . rosters . register_conn ( self ) \n 
msgbox = MsgBox . MsgBox ( self . _userid ) \n 
if self . rosters . get_xmpp_read ( self . _user . GetUID ( ) ) is None : \n 
~~~ self . rosters . set_xmpp_read ( self . _user . GetUID ( ) , msgbox . GetMsgCount ( all = False ) - msgbox . GetUnreadCount ( ) ) \n 
~~ self . check_msg ( ) \n 
~~ def get_loginid ( self ) : \n 
~~~ return self . _loginid \n 
~~ def recv_close ( self ) : \n 
return self . close ( ) \n 
~~ def stream_closed ( self ) : \n 
~~ def sent_close ( self ) : \n 
~~ def close ( self ) : \n 
~~~ if ( self . _closed ) : \n 
~~ self . _closed = True \n 
if ( self . _session ) : \n 
~~~ self . _session . Unregister ( ) \n 
~~ self . unbind_res ( ) \n 
self . rosters . unregister_conn ( self ) \n 
~~ @ xmpp . iq ( ) \n 
def ping ( self , iq ) : \n 
self . refresh ( ) \n 
return self . iq ( , iq ) \n 
~~ @ xmpp . stanza ( ) \n 
def message ( self , elem ) : \n 
to_jid = elem . get ( ) \n 
from_jid = elem . get ( ) \n 
if ( from_jid == None ) : \n 
~~~ return \n 
~~ text_body = None \n 
for child in elem : \n 
~~~ if ( child . tag . endswith ( ) ) : \n 
~~~ text_body = child . text \n 
~~ ~~ if ( text_body == None ) : \n 
~~ ret = self . rosters . send_msg ( from_jid , to_jid , text_body ) \n 
if ( ret <= 0 ) : \n 
errors = { \n 
if ( ret in errors ) : \n 
~~~ elem = self . E . message ( { : to_jid , \n 
: from_jid , \n 
: } , \n 
self . E . body ( errors [ ret ] ) ) \n 
self . recv ( from_jid , elem ) \n 
~~ ~~ ~~ def make_jid ( self , userid ) : \n 
~~~ return "%s@%s" % ( userid , self . _hostname ) \n 
~~ def refresh ( self ) : \n 
~~~ self . _userinfo . freshtime = int ( time . time ( ) ) \n 
self . _userinfo . save ( ) \n 
~~ def ping_result ( self , iq ) : \n 
~~~ self . refresh ( ) \n 
~~ def ping_client ( self ) : \n 
~~~ pingelem = self . E . ping ( xmlns = ) \n 
return self . iq ( , self . ping_result , pingelem ) \n 
~~ except Exception as e : \n 
Log . debug ( traceback . format_exc ( ) ) \n 
return False \n 
~~ ~~ def get_uid ( self ) : \n 
~~~ return self . _user . GetUID ( ) \n 
~~ def recv_msg ( self , from_ , msgtext ) : \n 
~~~ elem = self . E . message ( { : from_ , : unicode ( self . authJID ) } , \n 
self . E . body ( msgtext ) ) \n 
self . recv ( unicode ( self . authJID ) , elem ) \n 
~~ def check_msg ( self ) : \n 
msg_count = msgbox . GetMsgCount ( all = False ) \n 
my_pid = os . getpid ( ) \n 
xmpp_read = self . rosters . get_xmpp_read ( self . _user . GetUID ( ) ) \n 
if xmpp_read > msg_count : \n 
~~~ xmpp_read = 0 \n 
self . rosters . set_xmpp_read ( self . _user . GetUID ( ) , msg_count ) \n 
if xmpp_read < msg_count : \n 
~~~ return xmpp_read \n 
~~~ return - 1 \n 
~~ ~~ def deliver_msg ( self , start ) : \n 
for i in range ( start , msg_count ) : \n 
~~~ msghead = msgbox . LoadMsgHead ( i , all = False ) \n 
if msghead . topid == my_pid : \n 
~~~ msgtext = msgbox . LoadMsgText ( msghead ) \n 
self . recv_msg ( self . make_jid ( msghead . id ) , msgtext ) \n 
~~ ~~ ~~ def steal_msg ( self ) : \n 
msg_unread = msgbox . GetUnreadCount ( ) \n 
read_count = msg_count - msg_unread \n 
term_read = self . rosters . get_term_read ( self . get_uid ( ) ) \n 
term_stealed = self . rosters . get_term_stealed ( self . get_uid ( ) ) \n 
all_xmpp = True \n 
new_unread = { } \n 
for i in range ( read_count - 1 , msg_count ) : \n 
~~ msghead = msgbox . LoadMsgHead ( i , all = False ) \n 
if i >= read_count and all_xmpp : \n 
~~~ if msghead . topid == my_pid : \n 
~~~ msgbox . GetUnreadMsg ( ) \n 
~~~ all_xmpp = False \n 
~~ ~~ if msghead . topid == my_pid : \n 
~~~ session = self . rosters . find_session ( self . authJID . bare , msghead . topid ) \n 
if session is None or session . get_mode ( ) != modes . MSG : \n 
~~ if msghead . topid not in new_unread : \n 
new_unread [ msghead . topid ] = i \n 
~~ ~~ final_unread = { } \n 
to_steal = { } \n 
to_steal_begin = msg_count \n 
for pid in term_read : \n 
~~~ if pid in new_unread : \n 
~~~ if new_unread [ pid ] == term_read [ pid ] [ 0 ] : \n 
~~~ final_unread [ pid ] = ( term_read [ pid ] [ 0 ] , term_read [ pid ] [ 1 ] + 1 ) \n 
if final_unread [ pid ] [ 1 ] > STEAL_AFTER_SEEN : \n 
~~~ to_steal [ pid ] = final_unread [ pid ] \n 
if pid in term_stealed : \n 
~~~ steal_begin = max ( final_unread [ pid ] [ 0 ] , term_stealed [ pid ] + 1 ) \n 
~~~ steal_begin = final_unread [ pid ] [ 0 ] \n 
~~ if steal_begin < to_steal_begin : \n 
~~~ to_steal_begin = steal_begin \n 
~~ ~~ ~~ else : \n 
~~~ final_unread [ pid ] = ( new_unread [ pid ] , 1 ) \n 
pass \n 
~~ ~~ for pid in new_unread : \n 
~~~ if pid not in term_read : \n 
final_unread [ pid ] = ( new_unread [ pid ] , 1 ) \n 
~~ ~~ if to_steal : \n 
for i in range ( to_steal_begin , msg_count ) : \n 
msgbox . GetUnreadMsg ( ) \n 
~~ elif msghead . topid in to_steal : \n 
~~~ if msghead . topid not in term_stealed or i > term_stealed [ msghead . topid ] : \n 
msgtext = msgbox . LoadMsgText ( msghead ) \n 
term_stealed [ msghead . topid ] = i \n 
~~ ~~ ~~ ~~ self . rosters . set_term_read ( self . get_uid ( ) , final_unread ) \n 
def presence ( self , elem ) : \n 
if self . authJID == elem . get ( ) : \n 
~~~ if ( elem . get ( ) == None or ( not self . authJID . match_bare ( elem . get ( ) ) ) ) : \n 
~~~ return self . send_presence ( elem ) \n 
~~ ~~ self . recv_presence ( elem ) \n 
~~ def send_presence ( self , elem ) : \n 
direct = elem . get ( ) \n 
if not direct : \n 
~~~ self . rosters . broadcast ( self , elem ) \n 
if elem . get ( ) != : \n 
~~~ self . recv_presence ( elem ) \n 
~~ if not self . probed : \n 
~~~ self . probed = True \n 
self . rosters . probe ( self ) \n 
~~ ~~ elif not self . rosters . send ( self , direct , elem ) : \n 
~~~ self . send ( direct , elem ) \n 
~~ ~~ def recv_presence ( self , elem ) : \n 
if not self . rosters . recv ( self , elem ) : \n 
self . write ( elem ) \n 
~~ ~~ @ xmpp . iq ( ) \n 
def roster ( self , iq ) : \n 
roster = self . rosters . get ( self ) \n 
method = getattr ( self , % iq . get ( ) ) \n 
return method and method ( iq , roster ) \n 
~~ def get_roster ( self , iq , roster ) : \n 
~~~ query = self . E . query ( { : } ) \n 
for item in roster . items ( ) : \n 
~~~ query . append ( item ) \n 
~~ return self . iq ( , iq , query ) \n 
~~ def set_roster ( self , iq , roster ) : \n 
~~~ query = self . E . query ( xmlns = ) \n 
for item in iq [ 0 ] : \n 
~~~ result = roster . set ( item ) \n 
if result is not None : \n 
~~~ query . append ( result ) \n 
~~ ~~ if len ( query ) > 0 : \n 
~~~ self . push ( roster , query ) \n 
~~ return self . iq ( , iq ) \n 
~~ def push ( self , roster , query ) : \n 
for jid in roster . requests ( ) : \n 
~~~ for ( to , route ) in self . routes ( jid ) : \n 
~~~ route . iq ( , self . ignore , query ) \n 
~~ ~~ ~~ def ignore ( self , iq ) : \n 
def vcard ( self , iq ) : \n 
if iq . get ( ) == : \n 
~~~ if ( iq . get ( ) == None ) : \n 
~~~ target = iq . get ( ) \n 
~~ form_target = UCache . UCache . formalize_jid ( target ) \n 
name = form_target . partition ( ) [ 0 ] \n 
user = UserManager . UserManager . LoadUser ( name ) \n 
info = user . GetInfo ( ) \n 
desc = % ( info [ ] , info [ ] , info [ ] , \n 
info [ ] , info [ ] , info [ ] , info [ ] ) \n 
if ( in info ) : \n 
~~~ desc += "Plan:\\r%s" % ( info [ ] . replace ( , ) ) \n 
~~ vcard = self . E . vCard ( { : } , \n 
self . E ( , name ) , \n 
self . E ( , Util . Util . RemoveTags ( info [ ] ) ) , \n 
self . E ( , Util . Util . RemoveTags ( desc ) ) ) \n 
if ( iq . get ( ) == None ) : \n 
~~~ return self . iq ( , iq , vcard ) \n 
~~~ return self . iq ( , iq , vcard , { : iq . get ( ) } ) \n 
~~ ~~ ~~ @ xmpp . iq ( % __disco_info_ns__ ) \n 
def disco_info ( self , iq ) : \n 
target = iq . get ( ) \n 
if ( target . find ( ) < 0 ) : \n 
~~~ query = self . E . query ( { : __disco_info_ns__ } , \n 
self . E . identity ( { : , \n 
: , \n 
: Config . Config . GetString ( , ) , \n 
} ) ) \n 
features = [ __disco_info_ns__ , __disco_items_ns__ , __vcard_ns__ ] \n 
for feature in features : \n 
~~~ query . append ( self . E . feature ( { : feature } ) ) \n 
~~ ~~ return self . iq ( , iq , query , { : target } ) \n 
~~ @ xmpp . iq ( % __disco_items_ns__ ) \n 
def disco_items ( self , iq ) : \n 
~~~ query = self . E . query ( { : __disco_items_ns__ } ) \n 
~~ return self . iq ( , iq , query , { : target } ) \n 
### \n 
~~ ~~ from __future__ import print_function \n 
from __future__ import unicode_literals \n 
from __future__ import division \n 
from __future__ import absolute_import \n 
from builtins import range \n 
from future import standard_library \n 
standard_library . install_aliases ( ) \n 
PYTHON_VERSION = sys . version_info [ : 3 ] \n 
PY2 = ( PYTHON_VERSION [ 0 ] == 2 ) \n 
if PY2 : \n 
~~~ if PYTHON_VERSION < ( 2 , 7 , 9 ) : \n 
~~~ raise Exception ( ) \n 
~~ ~~ elif PYTHON_VERSION < ( 3 , 4 ) : \n 
~~ import hpOneView as hpov \n 
from pprint import pprint \n 
from hpOneView . common import uri \n 
import hpOneView . profile as profile \n 
def acceptEULA ( con ) : \n 
~~~ con . get_eula_status ( ) \n 
~~~ if con . get_eula_status ( ) is True : \n 
~~~ print ( ) \n 
con . set_eula ( ) \n 
~~ ~~ except Exception as e : \n 
print ( e ) \n 
~~ ~~ def login ( con , credential ) : \n 
~~~ con . login ( credential ) \n 
~~ ~~ def get_eg_uri_from_arg ( srv , name ) : \n 
~~~ if srv and name : \n 
~~~ if name . startswith ( ) and uri [ ] in name : \n 
~~~ return name \n 
~~~ egs = srv . get_enclosure_groups ( ) \n 
for eg in egs : \n 
~~~ if eg [ ] == name : \n 
~~~ return eg [ ] \n 
~~ ~~ ~~ ~~ return None \n 
~~ def get_sht_from_arg ( srv , name ) : \n 
~~~ shts = srv . get_server_hardware_types ( ) \n 
for sht in shts : \n 
~~~ if sht [ ] == name : \n 
~~~ return sht \n 
~~ def define_profile_template ( \n 
srv , \n 
name , \n 
desc , \n 
sp_desc , \n 
server_hwt , \n 
enc_group , \n 
affinity , \n 
hide_flexnics , \n 
conn_list , \n 
fw_settings , \n 
boot , \n 
bootmode ) : \n 
~~~ if conn_list : \n 
~~~ conn = json . loads ( open ( conn_list ) . read ( ) ) \n 
~~~ conn = [ ] \n 
~~ profile_template = srv . create_server_profile_template ( \n 
name = name , \n 
description = desc , \n 
serverProfileDescription = sp_desc , \n 
serverHardwareTypeUri = server_hwt , \n 
enclosureGroupUri = enc_group , \n 
affinity = affinity , \n 
hideUnusedFlexNics = hide_flexnics , \n 
profileConnectionV4 = conn , \n 
firmwareSettingsV3 = fw_settings , \n 
bootSettings = boot , \n 
bootModeSetting = bootmode ) \n 
if in profile_template : \n 
~~~ print ( , profile_template [ ] ) \n 
print ( , profile_template [ ] ) \n 
print ( ) \n 
for connection in profile_template [ ] : \n 
~~~ print ( , connection [ ] ) \n 
print ( , connection [ ] ) \n 
~~ print ( ) \n 
print ( , profile_template [ ] [ ] ) \n 
print ( , profile_template [ ] [ ] , ) \n 
~~~ pprint ( profile_template ) \n 
~~ ~~ def main ( ) : \n 
~~~ parser = argparse . ArgumentParser ( add_help = True , \n 
formatter_class = argparse . RawTextHelpFormatter , \n 
description = ) \n 
parser . add_argument ( , dest = , required = True , \n 
help = ) \n 
parser . add_argument ( , dest = , required = False , \n 
default = , \n 
parser . add_argument ( , dest = , \n 
required = True , \n 
required = False , \n 
required = False , choices = [ , ] , \n 
action = , \n 
nargs = , \n 
choices = [ , , ] , \n 
choices = [ , , , \n 
, ] , \n 
args = parser . parse_args ( ) \n 
credential = { : args . user , : args . passwd } \n 
con = hpov . connection ( args . host ) \n 
srv = hpov . servers ( con ) \n 
sts = hpov . settings ( con ) \n 
if args . proxy : \n 
~~~ con . set_proxy ( args . proxy . split ( ) [ 0 ] , args . proxy . split ( ) [ 1 ] ) \n 
~~ if args . cert : \n 
~~~ con . set_trusted_ssl_bundle ( args . cert ) \n 
~~ login ( con , credential ) \n 
acceptEULA ( con ) \n 
eg_uri = get_eg_uri_from_arg ( srv , args . enc_group ) \n 
sht = get_sht_from_arg ( srv , args . server_hwt ) \n 
fw_settings = profile . make_firmware_dict ( sts , args . baseline ) \n 
boot , bootmode = profile . make_boot_settings_dict ( srv , sht , args . disable_manage_boot , \n 
args . boot_order , args . boot_mode , args . pxe ) \n 
define_profile_template ( srv , \n 
args . name , \n 
args . desc , \n 
args . sp_desc , \n 
sht [ ] , \n 
eg_uri , \n 
args . affinity , \n 
args . hide_flexnics , \n 
args . conn_list , \n 
bootmode ) \n 
~~ if __name__ == : \n 
~~~ import argparse \n 
sys . exit ( main ( ) ) \n 
~~ from __future__ import print_function \n 
~~ ~~ def get_address_pools ( con , srv , types ) : \n 
~~~ if types == or types == : \n 
~~~ vmac = srv . get_vmac_pool ( ) \n 
for key in sorted ( vmac ) : \n 
~~~ print ( . format ( key , vmac [ key ] ) ) \n 
~~ if in vmac : \n 
~~~ for uri in vmac [ ] : \n 
~~~ ranges = con . get ( uri ) \n 
print ( , ranges [ ] ) \n 
~~ ~~ ~~ if types == or types == : \n 
~~~ vwwn = srv . get_vwwn_pool ( ) \n 
for key in sorted ( vwwn ) : \n 
~~~ print ( . format ( key , vwwn [ key ] ) ) \n 
~~ if in vwwn : \n 
~~~ for uri in vwwn [ ] : \n 
~~~ vsn = srv . get_vsn_pool ( ) \n 
for key in sorted ( vsn ) : \n 
~~~ print ( . format ( key , vsn [ key ] ) ) \n 
~~ if in vsn : \n 
~~~ for uri in vsn [ ] : \n 
~~ ~~ ~~ ~~ def main ( ) : \n 
choices = [ , , , ] , default = , \n 
credential = { : args . domain . upper ( ) , : args . user , : args . passwd } \n 
get_address_pools ( con , srv , args . types ) \n 
~~~ import sys \n 
import argparse \n 
~~ ~~ def get_managed_sans ( fcs ) : \n 
~~~ sans = fcs . get_managed_sans ( ) \n 
pprint ( sans ) \n 
~~ def main ( ) : \n 
fcs = hpov . fcsans ( con ) \n 
get_managed_sans ( fcs ) \n 
~~ ~~ def getpolicy ( sts ) : \n 
~~~ policy = sts . get_storage_vol_template_policy ( ) \n 
print ( policy [ ] ) \n 
getpolicy ( sts ) \n 
from __future__ import print_function \n 
__title__ = \n 
__version__ = \n 
__copyright__ = \n 
__license__ = \n 
__status__ = \n 
from hpOneView . common import * \n 
from hpOneView . connection import * \n 
from hpOneView . activity import * \n 
from hpOneView . exceptions import * \n 
class servers ( object ) : \n 
~~~ def __init__ ( self , con ) : \n 
~~~ self . _con = con \n 
self . _activity = activity ( con ) \n 
########################################################################### \n 
~~ def get_connections ( self , filter = ) : \n 
return get_members ( self . _con . get ( uri [ ] + filter ) ) \n 
~~ def get_connection ( self , server ) : \n 
body = self . _con . get ( server [ ] ) \n 
return body \n 
~~ def get_server_by_bay ( self , baynum ) : \n 
~~~ servers = get_members ( self . _con . get ( uri [ ] ) ) \n 
for server in servers : \n 
~~~ if server [ ] == baynum : \n 
~~~ return server \n 
~~ ~~ ~~ def get_server_by_name ( self , name ) : \n 
~~~ if server [ ] == name : \n 
~~ ~~ ~~ def get_available_servers ( self , server_hardware_type = None , \n 
enclosure_group = None , server_profile = None ) : \n 
~~~ filters = [ ] \n 
if server_hardware_type : \n 
~~~ filters . append ( + server_hardware_type [ ] ) \n 
~~ if enclosure_group : \n 
~~~ filters . append ( + enclosure_group [ ] ) \n 
~~ if server_profile : \n 
~~~ filters . append ( + server_profile [ ] ) \n 
~~ query_string = \n 
if filters : \n 
~~~ query_string = + . join ( filters ) \n 
~~ return self . _con . get ( uri [ ] + query_string ) \n 
~~ def get_servers ( self ) : \n 
~~~ return get_members ( self . _con . get ( uri [ ] ) ) \n 
~~ def get_utilization ( self , server ) : \n 
body = self . _con . get ( server [ ] + ) \n 
~~ def get_env_conf ( self , server ) : \n 
~~ def set_server_powerstate ( self , server , state , force = False , blocking = True , \n 
verbose = False ) : \n 
~~~ if state == and force is True : \n 
~~~ powerRequest = make_powerstate_dict ( , ) \n 
~~ elif state == and force is False : \n 
~~ elif state == : \n 
~~ task , body = self . _con . put ( server [ ] + , powerRequest ) \n 
if blocking is True : \n 
~~~ task = self . _activity . wait4task ( task , tout = 60 , verbose = verbose ) \n 
~~ return task \n 
~~ def delete_server ( self , server , force = False , blocking = True , verbose = False ) : \n 
~~~ if force : \n 
~~~ task , body = self . _con . delete ( server [ ] + ) \n 
~~~ task , body = self . _con . delete ( server [ ] ) \n 
~~ if blocking is True : \n 
~~~ task = self . _activity . wait4task ( task , tout = 600 , verbose = verbose ) \n 
~~ def update_server ( self , server ) : \n 
~~~ task , body = self . _con . put ( server [ ] , server ) \n 
~~ def add_server ( self , server , blocking = True , verbose = False ) : \n 
~~~ task , body = self . _con . post ( uri [ ] , server ) \n 
if in task and task [ ] . startswith ( ) : \n 
~~~ entity = self . _activity . get_task_associated_resource ( task ) \n 
server = self . _con . get ( entity [ ] ) \n 
return server \n 
~~ ~~ return task \n 
~~ def get_server_schema ( self ) : \n 
return self . _con . get ( uri [ ] + ) \n 
~~ def get_bios ( self , server ) : \n 
return self . _con . get ( server [ ] + ) \n 
~~ def get_ilo_sso_url ( self , server ) : \n 
~~ def get_java_remote_console_url ( self , server ) : \n 
~~ def get_remote_console_url ( self , server ) : \n 
~~ def get_server_hardware_types ( self ) : \n 
body = self . _con . get ( uri [ ] ) \n 
return get_members ( body ) \n 
~~ def remove_server_hardware_type ( self , server_hardware_type , force = False , blocking = True , verbose = False ) : \n 
if force : \n 
~~~ task , body = self . _con . delete ( server_hardware_type [ ] + ) \n 
~~~ task , body = self . _con . delete ( server_hardware_type [ ] ) \n 
~~ def get_server_type_schema ( self ) : \n 
~~ def get_server_hardware_type ( self , server_type ) : \n 
return self . _con . get ( server_type [ ] ) \n 
~~ def set_server_hardware_type ( self , server_hardware_type , name , description ) : \n 
request = make_server_type_dict ( name , description ) \n 
task , body = self . _con . put ( server_hardware_type [ ] , request ) \n 
return task \n 
~~ def create_server_profile ( self , \n 
affinity = , \n 
biosSettings = None , \n 
bootSettings = None , \n 
bootModeSetting = None , \n 
profileConnectionV4 = None , \n 
description = None , \n 
firmwareSettingsV3 = None , \n 
hideUnusedFlexNics = True , \n 
localStorageSettingsV3 = None , \n 
macType = , \n 
name = None , \n 
sanStorageV3 = None , \n 
serialNumber = None , \n 
serialNumberType = , \n 
serverHardwareTypeUri = None , \n 
serverHardwareUri = None , \n 
serverProfileTemplateUri = None , \n 
uuid = None , \n 
wwnType = , \n 
blocking = True , verbose = False ) : \n 
profile = make_ServerProfileV5 ( affinity , biosSettings , bootSettings , \n 
bootModeSetting , profileConnectionV4 , \n 
description , firmwareSettingsV3 , \n 
hideUnusedFlexNics , \n 
localStorageSettingsV3 , macType , name , \n 
sanStorageV3 , serialNumber , \n 
serialNumberType , serverHardwareTypeUri , \n 
serverHardwareUri , \n 
serverProfileTemplateUri , uuid , wwnType ) \n 
task , body = self . _con . post ( uri [ ] , profile ) \n 
if profile [ ] is None : \n 
~~~ tout = 600 \n 
~~~ tout = 3600 \n 
~~~ task = self . _activity . wait4task ( task , tout , verbose = verbose ) \n 
profile = self . _con . get ( entity [ ] ) \n 
return profile \n 
~~ def post_server_profile ( self , profile , blocking = True , verbose = False ) : \n 
~~ def remove_server_profile ( self , profile , force = False , blocking = True , verbose = False ) : \n 
~~~ task , body = self . _con . delete ( profile [ ] + ) \n 
~~~ task , body = self . _con . delete ( profile [ ] ) \n 
~~ def get_server_profiles ( self ) : \n 
~~~ body = self . _con . get ( uri [ ] ) \n 
~~ def update_server_profile ( self , profile , blocking = True , verbose = False ) : \n 
~~~ task , body = self . _con . put ( profile [ ] , profile ) \n 
~~~ if profile [ ] [ ] is None : \n 
~~ ~~ except Exception : \n 
~~~ task = self . _activity . wait4task ( task , tout = tout , verbose = verbose ) \n 
~~ profileResource = self . _activity . get_task_associated_resource ( task ) \n 
profile = self . _con . get ( profileResource [ ] ) \n 
~~ def update_server_profile_from_template ( self , profile , blocking = True , verbose = False ) : \n 
~~~ patch_request = [ { : , : , : } ] \n 
task , body = self . _con . patch ( profile [ ] , patch_request ) \n 
~~ ~~ def get_server_profile_by_name ( self , name ) : \n 
~~~ body = self . _con . get_entity_byfield ( uri [ ] , , name ) \n 
~~ def get_profile_message ( self , profile ) : \n 
message = self . _con . get ( profile [ ] + ) \n 
return message \n 
~~ def get_profile_compliance_preview ( self , profile ) : \n 
return self . _con . get ( profile [ ] + ) \n 
~~ def create_server_profile_template ( \n 
self , \n 
serverProfileDescription = None , \n 
enclosureGroupUri = None , \n 
affinity = None , \n 
hideUnusedFlexNics = None , \n 
blocking = True , \n 
profile_template = make_ServerProfileTemplateV1 ( name , \n 
description , \n 
serverProfileDescription , \n 
serverHardwareTypeUri , \n 
enclosureGroupUri , \n 
profileConnectionV4 , \n 
firmwareSettingsV3 , \n 
bootSettings , \n 
bootModeSetting ) \n 
task , body = self . _con . post ( uri [ ] , profile_template ) \n 
tout = 600 \n 
profile_template = self . _con . get ( entity [ ] ) \n 
return profile_template \n 
~~ def remove_server_profile_template ( self , profile_template , blocking = True , verbose = False ) : \n 
~~~ task , body = self . _con . delete ( profile_template [ ] ) \n 
~~ return body \n 
~~ def get_server_profile_templates ( self ) : \n 
~~ def get_server_profile_template_by_name ( self , name ) : \n 
~~ def update_server_profile_template ( self , profile_template , blocking = True , verbose = False ) : \n 
~~~ task , body = self . _con . put ( profile_template [ ] , profile_template ) \n 
~~ profileTemplateResource = self . _activity . get_task_associated_resource ( task ) \n 
profile = self . _con . get ( profileTemplateResource [ ] ) \n 
~~ def get_server_profile_from_template ( self , profile_template ) : \n 
~~~ profile = self . _con . get ( profile_template [ ] + ) \n 
~~ def get_enclosures ( self ) : \n 
~~ def add_enclosure ( self , enclosure , blocking = True , verbose = False ) : \n 
~~~ task , body = self . _con . post ( uri [ ] , enclosure ) \n 
if enclosure [ ] is : \n 
~~ elif enclosure [ ] is None : \n 
enclosure = self . _con . get ( entity [ ] ) \n 
return enclosure \n 
~~ def remove_enclosure ( self , enclosure , force = False , blocking = True , \n 
~~~ task , body = self . _con . delete ( enclosure [ ] + ) \n 
~~~ task , body = self . _con . delete ( enclosure [ ] ) \n 
~~ def create_enclosure_group ( self , associatedLIGs , name , \n 
powerMode = ) : \n 
egroup = make_EnclosureGroupV200 ( associatedLIGs , name , powerMode ) \n 
task , body = self . _con . post ( uri [ ] , egroup ) \n 
~~ def delete_enclosure_group ( self , egroup ) : \n 
~~~ self . _con . delete ( egroup [ ] ) \n 
~~ def get_enclosure_groups ( self ) : \n 
~~ def update_enclosure_group ( self , enclosuregroup ) : \n 
~~~ task , body = self . _con . put ( enclosuregroup [ ] , enclosuregroup ) \n 
~~ def get_pool ( self , pooltype ) : \n 
~~~ body = self . _con . get ( uri [ ] + + pooltype ) \n 
~~ def get_vmac_pool ( self ) : \n 
~~ def get_vwwn_pool ( self ) : \n 
~~ def get_vsn_pool ( self ) : \n 
~~ def get_profile_networks ( self ) : \n 
~~ def get_profile_schema ( self ) : \n 
~~~ return self . _con . get ( uri [ ] ) \n 
~~ def get_profile_available_servers ( self ) : \n 
~~ def get_profile_available_storage_systems ( self ) : \n 
~~ def get_profile_ports ( self ) : \n 
~~ def allocate_pool_ids ( self , url , count ) : \n 
~~~ allocatorUrl = % url \n 
allocatorBody = { : count } \n 
task , body = self . _con . put ( allocatorUrl , allocatorBody ) \n 
~~ def release_pool_ids ( self , url , idList ) : \n 
~~~ collectorUrl = % url \n 
collectorBody = { : idList } \n 
task , body = self . _con . put ( collectorUrl , collectorBody ) \n 
~~ def allocate_range_ids ( self , allocatorUrl , count ) : \n 
~~~ task , body = self . _con . put ( allocatorUrl , { : count } ) \n 
~~ def release_range_ids ( self , collectorUrl , idList ) : \n 
~~~ task , body = self . _con . put ( collectorUrl , { : idList } ) \n 
~~ def enable_range ( self , url ) : \n 
~~~ prange = self . _con . get ( url ) \n 
prange [ ] = True \n 
task , body = self . _con . put ( url , prange ) \n 
~~ def disable_range ( self , url ) : \n 
prange [ ] = False \n 
~~ ~~ from . constants import MILLI_MICROS , SECOND_MICROS , MINUTE_MICROS \n 
import calendar \n 
from datetime import datetime \n 
from dateutil import parser \n 
from dateutil . tz import tzlocal \n 
from . error import TimeConstructionError \n 
from . sanedelta import SaneDelta \n 
import pytz \n 
MICROS_TRANSLATIONS = ( \n 
( ( , , , , ) , MINUTE_MICROS ) , \n 
( ( , , , , ) , SECOND_MICROS ) , \n 
( ( , , , , ) , MILLI_MICROS ) , \n 
( ( , , , , ) , 1 ) ) \n 
MICROS_TRANSLATION_HASH = dict ( ( alt , v ) for k , v in MICROS_TRANSLATIONS for alt in k ) \n 
class SaneTime ( object ) : \n 
def __init__ ( self , * args , ** kwargs ) : \n 
super ( time , self ) . __init__ ( ) \n 
uss = set ( ) \n 
tzs = set ( ) \n 
naive_dt = None \n 
avoid_localize = False \n 
for k , v in kwargs . iteritems ( ) : \n 
~~~ if k in ( , ) : \n 
~~~ tzs . add ( SaneTime . to_timezone ( v ) ) \n 
~~ elif k in MICROS_TRANSLATION_HASH : \n 
~~~ uss . add ( MICROS_TRANSLATION_HASH [ k ] * v ) \n 
~~ ~~ args = list ( args ) \n 
if len ( args ) > 2 and len ( args ) <= 8 : \n 
~~~ args = [ datetime ( * args ) ] \n 
~~ if len ( args ) == 2 : \n 
~~~ tzs . add ( SaneTime . to_timezone ( args . pop ( ) ) ) \n 
~~ if len ( args ) == 1 : \n 
~~~ arg = args . pop ( ) \n 
if hasattr ( arg , ) : \n 
~~~ uss . add ( int ( arg ) ) \n 
if hasattr ( arg , ) : tzs . add ( arg . tz ) \n 
~~ elif isinstance ( arg , basestring ) : \n 
~~~ parts = arg . strip ( ) . split ( ) \n 
if len ( parts ) > 1 and parts [ - 1 ] . startswith ( ) : \n 
~~~ tzs . add ( SaneTime . to_timezone ( parts [ - 1 ] [ 1 : ] ) ) \n 
arg = . join ( parts [ : - 1 ] ) \n 
~~ except : pass \n 
~~ utc = arg . endswith ( ) or arg . endswith ( ) \n 
arg = parser . parse ( arg ) \n 
~~~ if utc : \n 
~~~ tzs . add ( pytz . utc ) \n 
arg = arg . replace ( tzinfo = None ) \n 
~~~ arg = arg . replace ( tzinfo = None ) \n 
~~~ avoid_localize = True \n 
arg = arg . astimezone ( pytz . utc ) . replace ( tzinfo = None ) \n 
~~ ~~ ~~ if type ( arg ) == datetime : \n 
~~~ naive_dt = arg \n 
if naive_dt . tzinfo : \n 
~~~ tzs . add ( SaneTime . to_timezone ( str ( naive_dt . tzinfo ) ) ) \n 
naive_dt = naive_dt . replace ( tzinfo = None ) \n 
~~ ~~ ~~ if len ( tzs ) > 1 : \n 
~~ self . tz = len ( tzs ) and tzs . pop ( ) or pytz . utc \n 
if naive_dt : \n 
~~~ if avoid_localize : \n 
~~~ uss . add ( SaneTime . utc_datetime_to_us ( naive_dt ) ) \n 
~~~ uss . add ( SaneTime . utc_datetime_to_us ( self . tz . localize ( naive_dt ) . astimezone ( pytz . utc ) ) ) \n 
~~ ~~ if len ( uss ) == 0 : \n 
~~~ uss . add ( SaneTime . utc_datetime_to_us ( datetime . utcnow ( ) ) ) \n 
~~ if len ( uss ) > 1 : \n 
~~ self . us = uss . pop ( ) \n 
if len ( args ) > 0 : \n 
~~ ~~ @ property \n 
def ms ( self ) : return self . us / MILLI_MICROS \n 
epoch_milliseconds = epoch_millis = milliseconds = millis = ms \n 
def s ( self ) : return self . us / SECOND_MICROS \n 
epoch_seconds = epoch_secs = seconds = secs = s \n 
def m ( self ) : return self . us / MINUTE_MICROS \n 
epoch_minutes = epoch_mins = minutes = mins = m \n 
def micros ( self ) : return self . us \n 
epoch_microseconds = epoch_micros = microseconds = micros \n 
def tz_name ( self ) : return self . tz . zone \n 
def tz_abbr ( self ) : return self . tz . _tzname \n 
def set_tz ( self , tz ) : \n 
~~~ self . tz = self . __class__ . to_timezone ( tz ) ; return self \n 
~~ def with_tz ( self , tz ) : \n 
~~~ return self . __class__ ( self . us , tz ) \n 
~~ @ property \n 
def _tuple ( self ) : return ( self . us , self . tz ) \n 
def strftime ( self , * args , ** kwargs ) : return self . datetime . strftime ( * args , ** kwargs ) \n 
def __cmp__ ( self , other ) : \n 
~~~ if not hasattr ( other , ) : other = SaneTime ( other ) \n 
return cmp ( self . us , int ( other ) ) \n 
~~ def __hash__ ( self ) : return self . us . __hash__ ( ) \n 
def __add__ ( self , operand ) : \n 
~~~ if not hasattr ( operand , ) : operand = SaneTime ( operand ) \n 
return self . __class__ ( self . us + int ( operand ) , tz = self . tz ) \n 
~~ def __sub__ ( self , operand ) : \n 
if isinstance ( operand , SaneTime ) : return SaneDelta ( self . us - int ( operand ) ) \n 
return self . __add__ ( - int ( operand ) ) \n 
~~ def __mul__ ( self , operand ) : \n 
~~~ return self . us * int ( operand ) \n 
~~ def __div__ ( self , operand ) : \n 
~~~ return self . us / int ( operand ) \n 
~~ def __int__ ( self ) : return int ( self . us ) \n 
def __long__ ( self ) : return long ( self . us ) \n 
def __repr__ ( self ) : return u"SaneTime(%s,%s)" % ( self . us , repr ( self . tz ) ) \n 
def __str__ ( self ) : return unicode ( self ) . encode ( ) \n 
def __unicode__ ( self ) : \n 
~~~ dt = self . datetime \n 
micros = u".%06d" % dt . microsecond if dt . microsecond else \n 
~~ def clone ( self ) : \n 
return self . __class__ ( self . us , self . tz ) \n 
def ny_str ( self ) : \n 
return self . ny_ndt . strftime ( ) \n 
def utc_datetime ( self ) : return SaneTime . us_to_utc_datetime ( self . us ) \n 
utc_dt = utc_datetime \n 
def utc_naive_datetime ( self ) : return self . utc_datetime . replace ( tzinfo = None ) \n 
utc_ndt = utc_naive_datetime \n 
def to_timezoned_datetime ( self , tz ) : return self . utc_datetime . astimezone ( SaneTime . to_timezone ( tz ) ) \n 
def to_timezoned_naive_datetime ( self , tz ) : return self . to_timezoned_datetime ( tz ) . replace ( tzinfo = None ) \n 
def datetime ( self ) : return self . to_timezoned_datetime ( self . tz ) \n 
dt = datetime \n 
def naive_datetime ( self ) : return self . to_timezoned_naive_datetime ( self . tz ) \n 
ndt = naive_datetime \n 
def ny_datetime ( self ) : return self . to_timezoned_datetime ( ) \n 
ny_dt = ny_datetime \n 
def ny_naive_datetime ( self ) : return self . to_timezoned_naive_datetime ( ) \n 
ny_ndt = ny_naive_datetime \n 
def year ( self ) : return self . dt . year \n 
def month ( self ) : return self . dt . month \n 
def day ( self ) : return self . dt . day \n 
def hour ( self ) : return self . dt . hour \n 
def minute ( self ) : return self . dt . minute \n 
def second ( self ) : return self . dt . second \n 
def microsecond ( self ) : return self . dt . microsecond \n 
@ classmethod \n 
def utc_datetime_to_us ( kls , dt ) : \n 
~~~ return calendar . timegm ( dt . timetuple ( ) ) * 1000 ** 2 + dt . microsecond \n 
~~ @ classmethod \n 
def us_to_utc_datetime ( kls , us ) : \n 
~~~ return pytz . utc . localize ( datetime . utcfromtimestamp ( us / 10 ** 6 ) ) . replace ( microsecond = us % 10 ** 6 ) \n 
def to_timezone ( kls , tz ) : \n 
~~~ if not isinstance ( tz , basestring ) : return tz \n 
return pytz . timezone ( tz ) \n 
~~ ~~ def ntime ( * args , ** kwargs ) : \n 
~~~ if args : \n 
~~~ if args [ 0 ] is None : return None \n 
~~ elif kwargs : \n 
~~~ if None in [ v for k , v in kwargs . iteritems ( ) if k != ] : return None \n 
~~ return SaneTime ( * args , ** kwargs ) \n 
~~ time = sanetime = SaneTime \n 
nsanetime = ntime \n 
from tastypie . authorization import Authorization \n 
from openpds . authentication import OAuth2Authentication \n 
from openpds . core . models import Profile , AuditEntry \n 
import settings \n 
import pdb \n 
class PDSAuthorization ( Authorization ) : \n 
~~~ audit_enabled = True \n 
scope = "" \n 
requester_uuid = "" \n 
def requester ( self ) : \n 
~~~ return self . requester_uuid \n 
~~ def trustWrapper ( self , datastore_owner ) : \n 
~~ def is_authorized ( self , request , object = None ) : \n 
~~~ authenticator = OAuth2Authentication ( self . scope ) \n 
if "datastore_owner__uuid" in request . REQUEST : \n 
~~~ authorized = True \n 
token = request . REQUEST [ "bearer_token" ] if "bearer_token" in request . REQUEST else request . META [ "HTTP_BEARER_TOKEN" ] \n 
datastore_owner_uuid = request . REQUEST [ "datastore_owner__uuid" ] \n 
datastore_owner , ds_owner_created = Profile . objects . get_or_create ( uuid = datastore_owner_uuid ) \n 
self . requester_uuid = authenticator . get_userinfo_from_token ( token , self . scope ) \n 
if self . requester_uuid is False or self . requester_uuid is None or len ( self . requester_uuid ) == 0 : \n 
~~~ self . requester_uuid = "not-specified" \n 
authorized = False \n 
~~ self . trustWrapper ( datastore_owner ) \n 
~~~ if ( self . audit_enabled ) : \n 
#pdb.set_trace() \n 
~~~ audit_entry = AuditEntry ( token = token ) \n 
audit_entry . method = request . method \n 
audit_entry . scope = self . scope \n 
audit_entry . purpose = request . REQUEST [ "purpose" ] if "purpose" in request . REQUEST else "" \n 
audit_entry . system_entity_toggle = request . REQUEST [ "system_entity" ] if "system_entity" in request . REQUEST else False \n 
audit_entry . datastore_owner = datastore_owner \n 
audit_entry . requester , created = Profile . objects . get_or_create ( uuid = self . requester_uuid ) \n 
audit_entry . script = request . path \n 
audit_entry . save ( ) \n 
~~~ print e \n 
~~ return authorized \n 
~~ return False \n 
~~ def __init__ ( self , scope , audit_enabled = True ) : \n 
~~~ self . scope = scope \n 
self . audit_enabled = audit_enabled \n 
from django import template \n 
register = template . Library ( ) \n 
class VerbatimNode ( template . Node ) : \n 
~~~ def __init__ ( self , text ) : \n 
~~~ self . text = text \n 
~~ def render ( self , context ) : \n 
~~~ return self . text \n 
~~ ~~ @ register . tag \n 
def verbatim ( parser , token ) : \n 
~~~ text = [ ] \n 
while 1 : \n 
~~~ token = parser . tokens . pop ( 0 ) \n 
if token . contents == : \n 
~~~ break \n 
~~ if token . token_type == template . TOKEN_VAR : \n 
~~~ text . append ( ) \n 
~~ elif token . token_type == template . TOKEN_BLOCK : \n 
~~ text . append ( token . contents ) \n 
if token . token_type == template . TOKEN_VAR : \n 
~~ ~~ return VerbatimNode ( . join ( text ) ) \n 
~~ from django . shortcuts import render_to_response \n 
from django . template import RequestContext \n 
#:coding=utf-8: \n 
from django . contrib . syndication . views import Feed as SyndicationFeed \n 
from django . core . urlresolvers import reverse \n 
from django . conf import settings \n 
from lifestream . models import Lifestream , Item \n 
class RecentItemsFeed ( SyndicationFeed ) : \n 
def link ( self , obj ) : \n 
~~~ return reverse ( , kwargs = { \n 
: obj . slug , \n 
} ) \n 
~~ def get_object ( self , bits ) : \n 
~~~ return Lifestream . objects . get ( slug = bits [ 0 ] ) \n 
~~ def items ( self , obj ) : \n 
~~~ return Item . objects . published ( ) . filter ( feed__lifestream = obj ) [ : 10 ] \n 
~~ def item_pubdate ( self , item ) : \n 
~~~ return item . date \n 
~~ def item_categories ( self , item ) : \n 
~~~ def item_categories ( self , item ) : \n 
~~~ if in settings . INSTALLED_APPS : \n 
~~~ return [ tag . name for tag in item . tag_set ] \n 
from functools import update_wrapper \n 
from google . appengine . api import users \n 
from werkzeug import redirect \n 
from werkzeug . exceptions import Forbidden \n 
from kay . utils import ( \n 
create_login_url , create_logout_url \n 
) \n 
from kay . utils . decorators import auto_adapt_to_methods \n 
def login_required ( func ) : \n 
~~~ def inner ( request , * args , ** kwargs ) : \n 
~~~ if request . user . is_anonymous ( ) : \n 
~~~ if request . is_xhr : \n 
~~~ return Forbidden ( ) \n 
~~~ return redirect ( create_login_url ( request . url ) ) \n 
~~ ~~ return func ( request , * args , ** kwargs ) \n 
~~ update_wrapper ( inner , func ) \n 
return inner \n 
~~ login_required = auto_adapt_to_methods ( login_required ) \n 
def admin_required ( func ) : \n 
~~~ if not request . user . is_admin : \n 
~~~ raise Forbidden ( \n 
description = \n 
create_logout_url ( request . url ) \n 
~~ admin_required = auto_adapt_to_methods ( admin_required ) \n 
PARSE_ERROR = - 32700 \n 
INVALID_REQUEST = - 32600 \n 
METHOD_NOT_FOUND = - 32601 \n 
INVALID_PARAMS = - 32602 \n 
INTERNAL_ERROR = - 32603 \n 
errors = { } \n 
~~~ import json \n 
~~ except ImportError : \n 
~~~ import django . utils . simplejson as json \n 
~~~ import simplejson as json \n 
~~ ~~ import sys \n 
import logging \n 
import itertools \n 
from werkzeug import Request , Response \n 
from werkzeug import exceptions \n 
class JsonRpcApplication ( object ) : \n 
~~~ def __init__ ( self , methods = None ) : \n 
~~~ if methods is not None : \n 
~~~ self . methods = methods \n 
~~~ self . methods = { } \n 
~~ ~~ def add_module ( self , mod , namespace = None ) : \n 
~~~ if namespace is None : \n 
~~~ namespace = mod . __name__ \n 
~~ for k , v in ( ( k , v ) for k , v in mod . __dict__ . iteritems ( ) \n 
if not k . startswith ( ) and callable ( v ) ) : \n 
~~~ self . add ( namespace + + k , v ) \n 
~~ ~~ def add ( self , name , func ) : \n 
~~~ self . methods [ name ] = func \n 
~~ def process ( self , data ) : \n 
~~~ if data . get ( ) != "2.0" : \n 
~~~ return { : , \n 
: data . get ( ) , \n 
: { : INVALID_REQUEST , \n 
: errors [ INVALID_REQUEST ] } } \n 
~~ if not in data : \n 
~~ methodname = data [ ] \n 
if not isinstance ( methodname , basestring ) : \n 
~~ if methodname . startswith ( ) : \n 
: { : METHOD_NOT_FOUND , \n 
: errors [ METHOD_NOT_FOUND ] } } \n 
~~ if methodname not in self . methods : \n 
~~ method = self . methods [ methodname ] \n 
~~~ params = data . get ( , [ ] ) \n 
if isinstance ( params , list ) : \n 
~~~ result = method ( * params ) \n 
~~ elif isinstance ( params , dict ) : \n 
~~~ result = method ( ** dict ( [ ( str ( k ) , v ) for k , v in params . iteritems ( ) ] ) ) \n 
~~ resdata = None \n 
if data . get ( ) : \n 
~~~ resdata = { \n 
: result , \n 
} \n 
~~ return resdata \n 
~~ except Exception , e : \n 
: { : INTERNAL_ERROR , \n 
: errors [ INTERNAL_ERROR ] , \n 
: str ( e ) } } \n 
~~ ~~ def __call__ ( self , environ , start_response ) : \n 
~~~ request = Request ( environ ) \n 
if request . method != "POST" : \n 
~~~ raise exceptions . MethodNotAllowed \n 
~~ if not request . content_type . startswith ( ) : \n 
~~~ raise exceptions . BadRequest \n 
~~ try : \n 
~~~ data = json . loads ( request . data ) \n 
~~ except ValueError , e : \n 
~~~ resdata = { : , \n 
: None , \n 
: { : PARSE_ERROR , \n 
: errors [ PARSE_ERROR ] } } \n 
~~~ if isinstance ( data , dict ) : \n 
~~~ resdata = self . process ( data ) \n 
~~ elif isinstance ( data , list ) : \n 
~~~ if len ( [ x for x in data if not isinstance ( x , dict ) ] ) : \n 
~~~ resdata = [ d for d in ( self . process ( d ) for d in data ) \n 
if d is not None ] \n 
~~ ~~ ~~ response = Response ( content_type = "application/json" ) \n 
if resdata : \n 
~~~ response . headers [ "Cache-Control" ] = "no-cache" \n 
response . headers [ "Pragma" ] = "no-cache" \n 
response . headers [ "Expires" ] = "-1" \n 
response . data = json . dumps ( resdata ) \n 
~~ return response ( environ , start_response ) \n 
~~ ~~ def getmod ( modname ) : \n 
~~~ __import__ ( modname ) \n 
~~ except ImportError , e : \n 
return None \n 
~~ mod = sys . modules [ modname ] \n 
return mod \n 
~~ def HTTPExceptionMiddleware ( app ) : \n 
~~~ def wrap ( environ , start_response ) : \n 
~~~ return app ( environ , start_response ) \n 
~~ except exceptions . HTTPException , e : \n 
~~~ return e ( environ , start_response ) \n 
~~ ~~ return wrap \n 
~~ def make_application ( methods ) : \n 
~~~ app = JsonRpcApplication ( ) \n 
for name , value in methods . iteritems ( ) : \n 
~~~ if ":" in value : \n 
~~~ modname , funcname = value . split ( ":" , 1 ) \n 
mod = getmod ( modname ) \n 
if mod : \n 
~~~ app . add ( name , getattr ( mod , funcname ) ) \n 
~~~ modname = value \n 
~~~ app . add_module ( mod , name ) \n 
~~ ~~ ~~ app = HTTPExceptionMiddleware ( app ) \n 
return app \n 
from jinja2 . runtime import Undefined \n 
__test__ = False \n 
number_re = re . compile ( ) \n 
regex_type = type ( number_re ) \n 
~~~ test_callable = callable \n 
~~ except NameError : \n 
~~~ def test_callable ( x ) : \n 
~~~ return hasattr ( x , ) \n 
~~ ~~ def test_odd ( value ) : \n 
return value % 2 == 1 \n 
~~ def test_even ( value ) : \n 
return value % 2 == 0 \n 
~~ def test_divisibleby ( value , num ) : \n 
return value % num == 0 \n 
~~ def test_defined ( value ) : \n 
return not isinstance ( value , Undefined ) \n 
~~ def test_undefined ( value ) : \n 
return isinstance ( value , Undefined ) \n 
~~ def test_none ( value ) : \n 
return value is None \n 
~~ def test_lower ( value ) : \n 
return unicode ( value ) . islower ( ) \n 
~~ def test_upper ( value ) : \n 
return unicode ( value ) . isupper ( ) \n 
~~ def test_string ( value ) : \n 
return isinstance ( value , basestring ) \n 
~~ def test_number ( value ) : \n 
return isinstance ( value , ( int , long , float , complex ) ) \n 
~~ def test_sequence ( value ) : \n 
~~~ len ( value ) \n 
value . __getitem__ \n 
~~ def test_sameas ( value , other ) : \n 
return value is other \n 
~~ def test_iterable ( value ) : \n 
~~~ iter ( value ) \n 
~~ except TypeError : \n 
~~ def test_escaped ( value ) : \n 
return hasattr ( value , ) \n 
~~ TESTS = { \n 
: test_odd , \n 
: test_even , \n 
: test_divisibleby , \n 
: test_defined , \n 
: test_undefined , \n 
: test_none , \n 
: test_lower , \n 
: test_upper , \n 
: test_string , \n 
: test_number , \n 
: test_sequence , \n 
: test_iterable , \n 
: test_callable , \n 
: test_sameas , \n 
: test_escaped \n 
import codecs \n 
import mimetypes \n 
from werkzeug . _internal import _proxy_repr , _missing , _empty_stream \n 
_locale_delim_re = re . compile ( ) \n 
def is_immutable ( self ) : \n 
~~~ raise TypeError ( % self . __class__ . __name__ ) \n 
~~ def iter_multi_items ( mapping ) : \n 
if isinstance ( mapping , MultiDict ) : \n 
~~~ for item in mapping . iteritems ( multi = True ) : \n 
~~~ yield item \n 
~~ ~~ elif isinstance ( mapping , dict ) : \n 
~~~ for key , value in mapping . iteritems ( ) : \n 
~~~ if isinstance ( value , ( tuple , list ) ) : \n 
~~~ for value in value : \n 
~~~ yield key , value \n 
~~~ for item in mapping : \n 
~~ ~~ ~~ class ImmutableListMixin ( object ) : \n 
def __reduce_ex__ ( self , protocol ) : \n 
~~~ return type ( self ) , ( list ( self ) , ) \n 
~~ def __delitem__ ( self , key ) : \n 
~~~ is_immutable ( self ) \n 
~~ def __delslice__ ( self , i , j ) : \n 
~~ def __iadd__ ( self , other ) : \n 
~~ __imul__ = __iadd__ \n 
def __setitem__ ( self , key , value ) : \n 
~~ def __setslice__ ( self , i , j , value ) : \n 
~~ def append ( self , item ) : \n 
~~ remove = append \n 
def extend ( self , iterable ) : \n 
~~ def insert ( self , pos , value ) : \n 
~~ def pop ( self , index = - 1 ) : \n 
~~ def reverse ( self ) : \n 
~~ def sort ( self , cmp = None , key = None , reverse = None ) : \n 
~~ ~~ class ImmutableList ( ImmutableListMixin , list ) : \n 
__repr__ = _proxy_repr ( list ) \n 
~~ class ImmutableDictMixin ( object ) : \n 
~~~ return type ( self ) , ( dict ( self ) , ) \n 
~~ def setdefault ( self , key , default = None ) : \n 
~~ def update ( self , * args , ** kwargs ) : \n 
~~ def pop ( self , key , default = None ) : \n 
~~ def popitem ( self ) : \n 
~~ def __setitem__ ( self , key , value ) : \n 
~~ def clear ( self ) : \n 
~~ ~~ class ImmutableMultiDictMixin ( ImmutableDictMixin ) : \n 
~~~ return type ( self ) , ( self . items ( multi = True ) , ) \n 
~~ def add ( self , key , value ) : \n 
~~ def popitemlist ( self ) : \n 
~~ def poplist ( self , key ) : \n 
~~ def setlist ( self , key , new_list ) : \n 
~~ def setlistdefault ( self , key , default_list = None ) : \n 
~~ ~~ class UpdateDictMixin ( object ) : \n 
on_update = None \n 
def calls_update ( name ) : \n 
~~~ def oncall ( self , * args , ** kw ) : \n 
~~~ rv = getattr ( super ( UpdateDictMixin , self ) , name ) ( * args , ** kw ) \n 
if self . on_update is not None : \n 
~~~ self . on_update ( self ) \n 
~~ return rv \n 
~~ oncall . __name__ = name \n 
return oncall \n 
~~ __setitem__ = calls_update ( ) \n 
__delitem__ = calls_update ( ) \n 
clear = calls_update ( ) \n 
pop = calls_update ( ) \n 
popitem = calls_update ( ) \n 
setdefault = calls_update ( ) \n 
update = calls_update ( ) \n 
del calls_update \n 
~~ class TypeConversionDict ( dict ) : \n 
def get ( self , key , default = None , type = None ) : \n 
~~~ rv = self [ key ] \n 
if type is not None : \n 
~~~ rv = type ( rv ) \n 
~~ ~~ except ( KeyError , ValueError ) : \n 
~~~ rv = default \n 
~~ ~~ class ImmutableTypeConversionDict ( ImmutableDictMixin , TypeConversionDict ) : \n 
def copy ( self ) : \n 
return TypeConversionDict ( self ) \n 
~~ def __copy__ ( self ) : \n 
~~ ~~ class MultiDict ( TypeConversionDict ) : \n 
KeyError = None \n 
def __init__ ( self , mapping = None ) : \n 
~~~ if isinstance ( mapping , MultiDict ) : \n 
~~~ dict . __init__ ( self , ( ( k , l [ : ] ) for k , l in mapping . iterlists ( ) ) ) \n 
~~ elif isinstance ( mapping , dict ) : \n 
~~~ tmp = { } \n 
for key , value in mapping . iteritems ( ) : \n 
~~~ value = list ( value ) \n 
~~~ value = [ value ] \n 
~~ tmp [ key ] = value \n 
~~ dict . __init__ ( self , tmp ) \n 
for key , value in mapping or ( ) : \n 
~~~ tmp . setdefault ( key , [ ] ) . append ( value ) \n 
~~ ~~ def __getstate__ ( self ) : \n 
~~~ return dict ( self . lists ( ) ) \n 
~~ def __setstate__ ( self , value ) : \n 
~~~ dict . clear ( self ) \n 
dict . update ( self , value ) \n 
~~ def __iter__ ( self ) : \n 
~~~ return self . iterkeys ( ) \n 
~~ def __getitem__ ( self , key ) : \n 
if key in self : \n 
~~~ return dict . __getitem__ ( self , key ) [ 0 ] \n 
~~ raise self . KeyError ( key ) \n 
dict . __setitem__ ( self , key , [ value ] ) \n 
dict . setdefault ( self , key , [ ] ) . append ( value ) \n 
~~ def getlist ( self , key , type = None ) : \n 
~~~ rv = dict . __getitem__ ( self , key ) \n 
~~ except KeyError : \n 
~~ if type is None : \n 
~~~ return list ( rv ) \n 
for item in rv : \n 
~~~ result . append ( type ( item ) ) \n 
~~ except ValueError : \n 
~~ ~~ return result \n 
dict . __setitem__ ( self , key , list ( new_list ) ) \n 
if key not in self : \n 
~~~ self [ key ] = default \n 
~~~ default = self [ key ] \n 
~~ return default \n 
~~~ default_list = list ( default_list or ( ) ) \n 
dict . __setitem__ ( self , key , default_list ) \n 
~~~ default_list = dict . __getitem__ ( self , key ) \n 
~~ return default_list \n 
~~ def items ( self , multi = False ) : \n 
return list ( self . iteritems ( multi ) ) \n 
~~ def lists ( self ) : \n 
return list ( self . iterlists ( ) ) \n 
~~ def values ( self ) : \n 
return [ self [ key ] for key in self . iterkeys ( ) ] \n 
~~ def listvalues ( self ) : \n 
return list ( self . iterlistvalues ( ) ) \n 
~~ def iteritems ( self , multi = False ) : \n 
for key , values in dict . iteritems ( self ) : \n 
~~~ if multi : \n 
~~~ for value in values : \n 
~~~ yield key , values [ 0 ] \n 
~~ ~~ ~~ def iterlists ( self ) : \n 
~~~ yield key , list ( values ) \n 
~~ ~~ def itervalues ( self ) : \n 
for values in dict . itervalues ( self ) : \n 
~~~ yield values [ 0 ] \n 
~~ ~~ def iterlistvalues ( self ) : \n 
~~~ yield list ( values ) \n 
~~ ~~ def copy ( self ) : \n 
return self . __class__ ( self ) \n 
~~ def to_dict ( self , flat = True ) : \n 
if flat : \n 
~~~ return dict ( self . iteritems ( ) ) \n 
~~ return dict ( self . lists ( ) ) \n 
~~ def update ( self , other_dict ) : \n 
for key , value in iter_multi_items ( other_dict ) : \n 
~~~ MultiDict . add ( self , key , value ) \n 
~~ ~~ def pop ( self , key , default = _missing ) : \n 
~~~ return dict . pop ( self , key ) [ 0 ] \n 
~~ except KeyError , e : \n 
~~~ if default is not _missing : \n 
~~~ return default \n 
~~ raise self . KeyError ( str ( e ) ) \n 
~~ ~~ def popitem ( self ) : \n 
~~~ item = dict . popitem ( self ) \n 
return ( item [ 0 ] , item [ 1 ] [ 0 ] ) \n 
~~~ raise self . KeyError ( str ( e ) ) \n 
~~ ~~ def poplist ( self , key ) : \n 
return dict . pop ( self , key , [ ] ) \n 
~~~ return dict . popitem ( self ) \n 
~~ ~~ def __repr__ ( self ) : \n 
~~~ return % ( self . __class__ . __name__ , self . items ( multi = True ) ) \n 
~~ ~~ class _omd_bucket ( object ) : \n 
__slots__ = ( , , , ) \n 
def __init__ ( self , omd , key , value ) : \n 
~~~ self . prev = omd . _last_bucket \n 
self . key = key \n 
self . value = value \n 
self . next = None \n 
if omd . _first_bucket is None : \n 
~~~ omd . _first_bucket = self \n 
~~ if omd . _last_bucket is not None : \n 
~~~ omd . _last_bucket . next = self \n 
~~ omd . _last_bucket = self \n 
~~ def unlink ( self , omd ) : \n 
~~~ if self . prev : \n 
~~~ self . prev . next = self . next \n 
~~ if self . next : \n 
~~~ self . next . prev = self . prev \n 
~~ if omd . _first_bucket is self : \n 
~~~ omd . _first_bucket = self . next \n 
~~ if omd . _last_bucket is self : \n 
~~~ omd . _last_bucket = self . prev \n 
~~ ~~ ~~ class OrderedMultiDict ( MultiDict ) : \n 
~~~ dict . __init__ ( self ) \n 
self . _first_bucket = self . _last_bucket = None \n 
if mapping is not None : \n 
~~~ OrderedMultiDict . update ( self , mapping ) \n 
~~ ~~ def __eq__ ( self , other ) : \n 
~~~ if not isinstance ( other , MultiDict ) : \n 
~~~ return NotImplemented \n 
~~ if isinstance ( other , OrderedMultiDict ) : \n 
~~~ iter1 = self . iteritems ( multi = True ) \n 
iter2 = other . iteritems ( multi = True ) \n 
~~~ for k1 , v1 in iter1 : \n 
~~~ k2 , v2 = iter2 . next ( ) \n 
if k1 != k2 or v1 != v2 : \n 
~~ ~~ ~~ except StopIteration : \n 
~~~ iter2 . next ( ) \n 
~~ except StopIteration : \n 
~~~ return True \n 
~~ if len ( self ) != len ( other ) : \n 
~~ for key , values in self . iterlists ( ) : \n 
~~~ if other . getlist ( key ) != values : \n 
~~ ~~ return True \n 
~~ def __ne__ ( self , other ) : \n 
~~~ return not self . __eq__ ( other ) \n 
~~ def __reduce_ex__ ( self , protocol ) : \n 
~~ def __getstate__ ( self ) : \n 
~~~ return self . items ( multi = True ) \n 
~~ def __setstate__ ( self , values ) : \n 
for key , value in values : \n 
~~~ self . add ( key , value ) \n 
~~ ~~ def __getitem__ ( self , key ) : \n 
~~~ if key in self : \n 
~~~ return dict . __getitem__ ( self , key ) [ 0 ] . value \n 
~~~ self . poplist ( key ) \n 
self . add ( key , value ) \n 
~~~ self . pop ( key ) \n 
~~ def iterkeys ( self ) : \n 
~~~ return ( key for key , value in self . iteritems ( ) ) \n 
~~ def itervalues ( self ) : \n 
~~~ return ( value for key , value in self . iteritems ( ) ) \n 
~~~ ptr = self . _first_bucket \n 
if multi : \n 
~~~ while ptr is not None : \n 
~~~ yield ptr . key , ptr . value \n 
ptr = ptr . next \n 
~~~ returned_keys = set ( ) \n 
while ptr is not None : \n 
~~~ if ptr . key not in returned_keys : \n 
~~~ returned_keys . add ( ptr . key ) \n 
yield ptr . key , ptr . value \n 
~~ ptr = ptr . next \n 
ptr = self . _first_bucket \n 
~~~ yield ptr . key , self . getlist ( ptr . key ) \n 
returned_keys . add ( ptr . key ) \n 
~~~ for key , values in self . iterlists ( ) : \n 
~~~ yield values \n 
~~ ~~ def add ( self , key , value ) : \n 
~~~ dict . setdefault ( self , key , [ ] ) . append ( _omd_bucket ( self , key , value ) ) \n 
~~~ return [ x . value for x in rv ] \n 
~~~ result . append ( type ( item . value ) ) \n 
for value in new_list : \n 
~~ ~~ def setlistdefault ( self , key , default_list = None ) : \n 
~~~ raise TypeError ( \n 
~~ def update ( self , mapping ) : \n 
~~~ for key , value in iter_multi_items ( mapping ) : \n 
~~~ OrderedMultiDict . add ( self , key , value ) \n 
~~~ buckets = dict . pop ( self , key , ( ) ) \n 
for bucket in buckets : \n 
~~~ bucket . unlink ( self ) \n 
~~ return [ x . value for x in buckets ] \n 
~~ def pop ( self , key , default = _missing ) : \n 
~~~ buckets = dict . pop ( self , key ) \n 
~~ for bucket in buckets : \n 
~~ return buckets [ 0 ] . value \n 
~~~ key , buckets = dict . popitem ( self ) \n 
~~ return key , buckets [ 0 ] . value \n 
~~ return key , [ x . value for x in buckets ] \n 
~~ ~~ def _options_header_vkw ( value , kw ) : \n 
~~~ if not kw : \n 
~~~ return value \n 
~~ return dump_options_header ( value , dict ( ( k . replace ( , ) , v ) \n 
for k , v in kw . items ( ) ) ) \n 
~~ class Headers ( object ) : \n 
def __init__ ( self , defaults = None , _list = None ) : \n 
~~~ if _list is None : \n 
~~~ _list = [ ] \n 
~~ self . _list = _list \n 
if defaults is not None : \n 
~~~ if isinstance ( defaults , ( list , Headers ) ) : \n 
~~~ self . _list . extend ( defaults ) \n 
~~~ self . extend ( defaults ) \n 
~~ ~~ ~~ @ classmethod \n 
def linked ( cls , headerlist ) : \n 
return cls ( _list = headerlist ) \n 
~~ def __getitem__ ( self , key , _index_operation = True ) : \n 
~~~ if _index_operation : \n 
~~~ if isinstance ( key , ( int , long ) ) : \n 
~~~ return self . _list [ key ] \n 
~~ elif isinstance ( key , slice ) : \n 
~~~ return self . __class__ ( self . _list [ key ] ) \n 
~~ ~~ ikey = key . lower ( ) \n 
for k , v in self . _list : \n 
~~~ if k . lower ( ) == ikey : \n 
~~~ return v \n 
~~ ~~ raise self . KeyError ( key ) \n 
~~ def __eq__ ( self , other ) : \n 
~~~ return other . __class__ is self . __class__ and set ( other . _list ) == set ( self . _list ) \n 
~~ def get ( self , key , default = None , type = None ) : \n 
~~~ rv = self . __getitem__ ( key , _index_operation = False ) \n 
~~~ return rv \n 
~~~ return type ( rv ) \n 
~~ ~~ def getlist ( self , key , type = None ) : \n 
ikey = key . lower ( ) \n 
result = [ ] \n 
for k , v in self : \n 
~~~ if type is not None : \n 
~~~ v = type ( v ) \n 
~~ ~~ result . append ( v ) \n 
~~ def get_all ( self , name ) : \n 
return self . getlist ( name ) \n 
~~ def iteritems ( self , lower = False ) : \n 
~~~ for key , value in self : \n 
~~~ if lower : \n 
~~~ key = key . lower ( ) \n 
~~ yield key , value \n 
~~ ~~ def iterkeys ( self , lower = False ) : \n 
~~~ for key , _ in self . iteritems ( lower ) : \n 
~~~ yield key \n 
~~~ for _ , value in self . iteritems ( ) : \n 
~~~ yield value \n 
~~ ~~ def keys ( self , lower = False ) : \n 
~~~ return list ( self . iterkeys ( lower ) ) \n 
~~~ return list ( self . itervalues ( ) ) \n 
~~ def items ( self , lower = False ) : \n 
~~~ return list ( self . iteritems ( lower ) ) \n 
~~ def extend ( self , iterable ) : \n 
if isinstance ( iterable , dict ) : \n 
~~~ for key , value in iterable . iteritems ( ) : \n 
~~~ for v in value : \n 
~~~ self . add ( key , v ) \n 
~~~ for key , value in iterable : \n 
~~ ~~ ~~ def __delitem__ ( self , key , _index_operation = True ) : \n 
~~~ if _index_operation and isinstance ( key , ( int , long , slice ) ) : \n 
~~~ del self . _list [ key ] \n 
~~ key = key . lower ( ) \n 
new = [ ] \n 
~~~ if k . lower ( ) != key : \n 
~~~ new . append ( ( k , v ) ) \n 
~~ ~~ self . _list [ : ] = new \n 
~~ def remove ( self , key ) : \n 
return self . __delitem__ ( key , _index_operation = False ) \n 
~~ def pop ( self , key = None , default = _missing ) : \n 
if key is None : \n 
~~~ return self . _list . pop ( ) \n 
~~ if isinstance ( key , ( int , long ) ) : \n 
~~~ return self . _list . pop ( key ) \n 
self . remove ( key ) \n 
~~ raise \n 
return self . pop ( ) \n 
~~ def __contains__ ( self , key ) : \n 
~~~ self . __getitem__ ( key , _index_operation = False ) \n 
~~ has_key = __contains__ \n 
def __iter__ ( self ) : \n 
return iter ( self . _list ) \n 
~~ def __len__ ( self ) : \n 
~~~ return len ( self . _list ) \n 
~~ def add ( self , _key , _value , ** kw ) : \n 
self . _list . append ( ( _key , _options_header_vkw ( _value , kw ) ) ) \n 
~~ def add_header ( self , _key , _value , ** _kw ) : \n 
self . add ( _key , _value , ** _kw ) \n 
del self . _list [ : ] \n 
~~ def set ( self , _key , _value , ** kw ) : \n 
lc_key = _key . lower ( ) \n 
_value = _options_header_vkw ( _value , kw ) \n 
for idx , ( old_key , old_value ) in enumerate ( self . _list ) : \n 
~~~ if old_key . lower ( ) == lc_key : \n 
~~~ self . _list [ idx ] = ( _key , _value ) \n 
break \n 
~~~ return self . add ( _key , _value ) \n 
~~ self . _list [ idx + 1 : ] = [ ( k , v ) for k , v in self . _list [ idx + 1 : ] \n 
if k . lower ( ) != lc_key ] \n 
~~ def setdefault ( self , key , value ) : \n 
~~~ return self [ key ] \n 
~~ self . set ( key , value ) \n 
return value \n 
if isinstance ( key , ( slice , int , long ) ) : \n 
~~~ self . _list [ key ] = value \n 
~~~ self . set ( key , value ) \n 
~~ ~~ def to_list ( self , charset = ) : \n 
~~~ if isinstance ( v , unicode ) : \n 
~~~ v = v . encode ( charset ) \n 
~~~ v = str ( v ) \n 
~~ result . append ( ( k , v ) ) \n 
~~ def copy ( self ) : \n 
~~~ return self . __class__ ( self . _list ) \n 
~~~ return self . copy ( ) \n 
~~ def __str__ ( self , charset = ) : \n 
strs = [ ] \n 
for key , value in self . to_list ( charset ) : \n 
~~~ strs . append ( % ( key , value ) ) \n 
~~ strs . append ( ) \n 
return . join ( strs ) \n 
~~ def __repr__ ( self ) : \n 
~~~ return % ( \n 
self . __class__ . __name__ , \n 
list ( self ) \n 
~~ ~~ class ImmutableHeadersMixin ( object ) : \n 
def __delitem__ ( self , key ) : \n 
~~ set = __setitem__ \n 
def add ( self , item ) : \n 
~~ remove = add_header = add \n 
~~ def setdefault ( self , key , default ) : \n 
~~ ~~ class EnvironHeaders ( ImmutableHeadersMixin , Headers ) : \n 
def __init__ ( self , environ ) : \n 
~~~ self . environ = environ \n 
def linked ( cls , environ ) : \n 
% cls . __name__ ) \n 
~~~ return self . environ is other . environ \n 
~~ def __getitem__ ( self , key , _index_operation = False ) : \n 
~~~ key = key . upper ( ) . replace ( , ) \n 
if key in ( , ) : \n 
~~~ return self . environ [ key ] \n 
~~ return self . environ [ + key ] \n 
~~~ return len ( list ( iter ( self ) ) ) \n 
~~~ for key , value in self . environ . iteritems ( ) : \n 
~~~ if key . startswith ( ) and key not in ( , ) : \n 
~~~ yield key [ 5 : ] . replace ( , ) . title ( ) , value \n 
~~ elif key in ( , ) : \n 
~~~ yield key . replace ( , ) . title ( ) , value \n 
~~ ~~ ~~ def copy ( self ) : \n 
~~ ~~ class CombinedMultiDict ( ImmutableMultiDictMixin , MultiDict ) : \n 
~~~ return type ( self ) , ( self . dicts , ) \n 
~~ def __init__ ( self , dicts = None ) : \n 
~~~ self . dicts = dicts or [ ] \n 
def fromkeys ( cls ) : \n 
~~~ raise TypeError ( % \n 
cls . __name__ ) \n 
~~~ for d in self . dicts : \n 
~~~ if key in d : \n 
~~~ return d [ key ] \n 
~~~ return type ( d [ key ] ) \n 
~~ ~~ return d [ key ] \n 
~~ ~~ return default \n 
~~~ rv = [ ] \n 
for d in self . dicts : \n 
~~~ rv . extend ( d . getlist ( key , type ) ) \n 
~~ def keys ( self ) : \n 
~~~ rv = set ( ) \n 
~~~ rv . update ( d . keys ( ) ) \n 
~~ return list ( rv ) \n 
~~~ found = set ( ) \n 
~~~ for key , value in d . iteritems ( multi ) : \n 
~~ elif key not in found : \n 
~~~ found . add ( key ) \n 
yield key , value \n 
~~ ~~ ~~ ~~ def itervalues ( self ) : \n 
~~~ for key , value in self . iteritems ( ) : \n 
~~ ~~ def values ( self ) : \n 
~~~ return list ( self . iteritems ( multi ) ) \n 
~~ def iterlists ( self ) : \n 
~~~ rv = { } \n 
~~~ for key , values in d . iterlists ( ) : \n 
~~~ rv . setdefault ( key , [ ] ) . extend ( values ) \n 
~~ ~~ return rv . iteritems ( ) \n 
~~~ return list ( self . iterlists ( ) ) \n 
~~ def iterlistvalues ( self ) : \n 
~~~ return ( x [ 0 ] for x in self . lists ( ) ) \n 
~~~ return list ( self . iterlistvalues ( ) ) \n 
~~~ return iter ( self . keys ( ) ) \n 
~~ __iter__ = iterkeys \n 
return self . __class__ ( self . dicts [ : ] ) \n 
rv = { } \n 
for d in reversed ( self . dicts ) : \n 
~~~ rv . update ( d . to_dict ( flat ) ) \n 
~~~ return len ( self . keys ( ) ) \n 
~~ ~~ return False \n 
def __repr__ ( self ) : \n 
~~~ return % ( self . __class__ . __name__ , self . dicts ) \n 
~~ ~~ class FileMultiDict ( MultiDict ) : \n 
def add_file ( self , name , file , filename = None , content_type = None ) : \n 
if isinstance ( file , FileStorage ) : \n 
~~~ self [ name ] = file \n 
~~ if isinstance ( file , basestring ) : \n 
~~~ if filename is None : \n 
~~~ filename = file \n 
~~ file = open ( file , ) \n 
~~ if filename and content_type is None : \n 
~~~ content_type = mimetypes . guess_type ( filename ) [ 0 ] or \n 
~~ self [ name ] = FileStorage ( file , filename , name , content_type ) \n 
~~ ~~ class ImmutableDict ( ImmutableDictMixin , dict ) : \n 
__repr__ = _proxy_repr ( dict ) \n 
return dict ( self ) \n 
~~ ~~ class ImmutableMultiDict ( ImmutableMultiDictMixin , MultiDict ) : \n 
return MultiDict ( self ) \n 
~~ ~~ class ImmutableOrderedMultiDict ( ImmutableMultiDictMixin , OrderedMultiDict ) : \n 
return OrderedMultiDict ( self ) \n 
~~ ~~ class Accept ( ImmutableList ) : \n 
def __init__ ( self , values = ( ) ) : \n 
~~~ if values is None : \n 
~~~ list . __init__ ( self ) \n 
self . provided = False \n 
~~ elif isinstance ( values , Accept ) : \n 
~~~ self . provided = values . provided \n 
list . __init__ ( self , values ) \n 
~~~ self . provided = True \n 
values = [ ( a , b ) for b , a in values ] \n 
values . sort ( ) \n 
values . reverse ( ) \n 
list . __init__ ( self , [ ( a , b ) for b , a in values ] ) \n 
~~ ~~ def _value_matches ( self , value , item ) : \n 
return item == or item . lower ( ) == value . lower ( ) \n 
if isinstance ( key , basestring ) : \n 
~~~ return self . quality ( key ) \n 
~~ return list . __getitem__ ( self , key ) \n 
~~ def quality ( self , key ) : \n 
for item , quality in self : \n 
~~~ if self . _value_matches ( key , item ) : \n 
~~~ return quality \n 
~~ ~~ return 0 \n 
~~ def __contains__ ( self , value ) : \n 
~~~ for item , quality in self : \n 
~~~ if self . _value_matches ( value , item ) : \n 
. join ( % ( x , y ) for x , y in self ) \n 
~~ def index ( self , key ) : \n 
~~~ for idx , ( item , quality ) in enumerate ( self ) : \n 
~~~ return idx \n 
~~ ~~ raise ValueError ( key ) \n 
~~ return list . index ( self , key ) \n 
~~ def find ( self , key ) : \n 
~~~ return self . index ( key ) \n 
return list ( self . itervalues ( ) ) \n 
for item in self : \n 
~~~ yield item [ 0 ] \n 
~~ ~~ def to_header ( self ) : \n 
for value , quality in self : \n 
~~~ if quality != 1 : \n 
~~~ value = % ( value , quality ) \n 
~~ result . append ( value ) \n 
~~ return . join ( result ) \n 
~~ def __str__ ( self ) : \n 
~~~ return self . to_header ( ) \n 
~~ def best_match ( self , matches , default = None ) : \n 
best_quality = - 1 \n 
result = default \n 
for server_item in matches : \n 
~~~ for client_item , quality in self : \n 
~~~ if quality <= best_quality : \n 
~~ if self . _value_matches ( client_item , server_item ) : \n 
~~~ best_quality = quality \n 
result = server_item \n 
~~ ~~ ~~ return result \n 
def best ( self ) : \n 
if self : \n 
~~~ return self [ 0 ] [ 0 ] \n 
~~ ~~ ~~ class MIMEAccept ( Accept ) : \n 
def _value_matches ( self , value , item ) : \n 
~~~ def _normalize ( x ) : \n 
~~~ x = x . lower ( ) \n 
return x == and ( , ) or x . split ( , 1 ) \n 
~~ if not in value : \n 
~~~ raise ValueError ( % value ) \n 
~~ value_type , value_subtype = _normalize ( value ) \n 
if value_type == and value_subtype != : \n 
~~ if not in item : \n 
~~ item_type , item_subtype = _normalize ( item ) \n 
if item_type == and item_subtype != : \n 
~~ return ( \n 
( item_type == item_subtype == or \n 
value_type == value_subtype == ) or \n 
( item_type == value_type and ( item_subtype == or \n 
value_subtype == or \n 
item_subtype == value_subtype ) ) \n 
def accept_html ( self ) : \n 
return ( \n 
in self or \n 
self . accept_xhtml \n 
def accept_xhtml ( self ) : \n 
in self \n 
~~ ~~ class LanguageAccept ( Accept ) : \n 
~~~ def _normalize ( language ) : \n 
~~~ return _locale_delim_re . split ( language . lower ( ) ) \n 
~~ return item == or _normalize ( value ) == _normalize ( item ) \n 
~~ ~~ class CharsetAccept ( Accept ) : \n 
~~~ def _normalize ( name ) : \n 
~~~ return codecs . lookup ( name ) . name \n 
~~ except LookupError : \n 
~~~ return name . lower ( ) \n 
~~ ~~ return item == or _normalize ( value ) == _normalize ( item ) \n 
~~ ~~ def cache_property ( key , empty , type ) : \n 
return property ( lambda x : x . _get_cache_value ( key , empty , type ) , \n 
lambda x , v : x . _set_cache_value ( key , v , type ) , \n 
lambda x : x . _del_cache_value ( key ) , \n 
% key ) \n 
~~ class _CacheControl ( UpdateDictMixin , dict ) : \n 
no_cache = cache_property ( , , None ) \n 
no_store = cache_property ( , None , bool ) \n 
max_age = cache_property ( , - 1 , int ) \n 
no_transform = cache_property ( , None , None ) \n 
def __init__ ( self , values = ( ) , on_update = None ) : \n 
~~~ dict . __init__ ( self , values or ( ) ) \n 
self . on_update = on_update \n 
self . provided = values is not None \n 
~~ def _get_cache_value ( self , key , empty , type ) : \n 
if type is bool : \n 
~~~ return key in self \n 
~~ if key in self : \n 
~~~ value = self [ key ] \n 
if value is None : \n 
~~~ return empty \n 
~~ elif type is not None : \n 
~~~ value = type ( value ) \n 
~~ ~~ return value \n 
~~ ~~ def _set_cache_value ( self , key , value , type ) : \n 
~~~ if value : \n 
~~~ self [ key ] = None \n 
~~~ self . pop ( key , None ) \n 
~~~ if value is None : \n 
~~ elif value is True : \n 
~~~ self [ key ] = value \n 
~~ ~~ ~~ def _del_cache_value ( self , key ) : \n 
~~~ del self [ key ] \n 
return dump_header ( self ) \n 
self . to_header ( ) \n 
~~ ~~ class RequestCacheControl ( ImmutableDictMixin , _CacheControl ) : \n 
max_stale = cache_property ( , , int ) \n 
min_fresh = cache_property ( , , int ) \n 
only_if_cached = cache_property ( , None , bool ) \n 
~~ class ResponseCacheControl ( _CacheControl ) : \n 
public = cache_property ( , None , bool ) \n 
private = cache_property ( , , None ) \n 
must_revalidate = cache_property ( , None , bool ) \n 
proxy_revalidate = cache_property ( , None , bool ) \n 
s_maxage = cache_property ( , None , None ) \n 
~~ _CacheControl . cache_property = staticmethod ( cache_property ) \n 
class CallbackDict ( UpdateDictMixin , dict ) : \n 
def __init__ ( self , initial = None , on_update = None ) : \n 
~~~ dict . __init__ ( self , initial or ( ) ) \n 
dict . __repr__ ( self ) \n 
~~ ~~ class HeaderSet ( object ) : \n 
def __init__ ( self , headers = None , on_update = None ) : \n 
~~~ self . _headers = list ( headers or ( ) ) \n 
self . _set = set ( [ x . lower ( ) for x in self . _headers ] ) \n 
~~ def add ( self , header ) : \n 
self . update ( ( header , ) ) \n 
~~ def remove ( self , header ) : \n 
key = header . lower ( ) \n 
if key not in self . _set : \n 
~~~ raise KeyError ( header ) \n 
~~ self . _set . remove ( key ) \n 
for idx , key in enumerate ( self . _headers ) : \n 
~~~ if key . lower ( ) == header : \n 
~~~ del self . _headers [ idx ] \n 
~~ ~~ if self . on_update is not None : \n 
~~ ~~ def update ( self , iterable ) : \n 
inserted_any = False \n 
for header in iterable : \n 
~~~ key = header . lower ( ) \n 
~~~ self . _headers . append ( header ) \n 
self . _set . add ( key ) \n 
inserted_any = True \n 
~~ ~~ if inserted_any and self . on_update is not None : \n 
~~ ~~ def discard ( self , header ) : \n 
~~~ return self . remove ( header ) \n 
~~ ~~ def find ( self , header ) : \n 
header = header . lower ( ) \n 
for idx , item in enumerate ( self . _headers ) : \n 
~~~ if item . lower ( ) == header : \n 
~~ ~~ return - 1 \n 
~~ def index ( self , header ) : \n 
rv = self . find ( header ) \n 
if rv < 0 : \n 
~~~ raise IndexError ( header ) \n 
self . _set . clear ( ) \n 
del self . _headers [ : ] \n 
~~ ~~ def as_set ( self , preserve_casing = False ) : \n 
if preserve_casing : \n 
~~~ return set ( self . _headers ) \n 
~~ return set ( self . _set ) \n 
~~ def to_header ( self ) : \n 
return . join ( map ( quote_header_value , self . _headers ) ) \n 
~~ def __getitem__ ( self , idx ) : \n 
~~~ return self . _headers [ idx ] \n 
~~ def __delitem__ ( self , idx ) : \n 
~~~ rv = self . _headers . pop ( idx ) \n 
self . _set . remove ( rv . lower ( ) ) \n 
~~ ~~ def __setitem__ ( self , idx , value ) : \n 
~~~ old = self . _headers [ idx ] \n 
self . _set . remove ( old . lower ( ) ) \n 
self . _headers [ idx ] = value \n 
self . _set . add ( value . lower ( ) ) \n 
~~ ~~ def __contains__ ( self , header ) : \n 
~~~ return header . lower ( ) in self . _set \n 
~~~ return len ( self . _set ) \n 
~~~ return iter ( self . _headers ) \n 
~~ def __nonzero__ ( self ) : \n 
~~~ return bool ( self . _set ) \n 
self . _headers \n 
~~ ~~ class ETags ( object ) : \n 
def __init__ ( self , strong_etags = None , weak_etags = None , star_tag = False ) : \n 
~~~ self . _strong = frozenset ( not star_tag and strong_etags or ( ) ) \n 
self . _weak = frozenset ( weak_etags or ( ) ) \n 
self . star_tag = star_tag \n 
~~ def as_set ( self , include_weak = False ) : \n 
rv = set ( self . _strong ) \n 
if include_weak : \n 
~~~ rv . update ( self . _weak ) \n 
~~ def is_weak ( self , etag ) : \n 
return etag in self . _weak \n 
~~ def contains_weak ( self , etag ) : \n 
return self . is_weak ( etag ) or self . contains ( etag ) \n 
~~ def contains ( self , etag ) : \n 
if self . star_tag : \n 
~~ return etag in self . _strong \n 
~~ def contains_raw ( self , etag ) : \n 
etag , weak = unquote_etag ( etag ) \n 
if weak : \n 
~~~ return self . contains_weak ( etag ) \n 
~~ return self . contains ( etag ) \n 
~~ return . join ( \n 
[ \'"%s"\' % x for x in self . _strong ] + \n 
[ \'w/"%s"\' % x for x in self . _weak ] \n 
~~ def __call__ ( self , etag = None , data = None , include_weak = False ) : \n 
~~~ if [ etag , data ] . count ( None ) != 1 : \n 
~~~ raise TypeError ( ) \n 
~~ if etag is None : \n 
~~~ etag = generate_etag ( data ) \n 
~~ if include_weak : \n 
~~~ if etag in self . _weak : \n 
~~ ~~ return etag in self . _strong \n 
~~~ return bool ( self . star_tag or self . _strong ) \n 
~~~ return iter ( self . _strong ) \n 
~~ def __contains__ ( self , etag ) : \n 
~~~ return self . contains ( etag ) \n 
~~~ return % ( self . __class__ . __name__ , str ( self ) ) \n 
~~ ~~ class Authorization ( ImmutableDictMixin , dict ) : \n 
def __init__ ( self , auth_type , data = None ) : \n 
~~~ dict . __init__ ( self , data or { } ) \n 
self . type = auth_type \n 
~~ username = property ( lambda x : x . get ( ) , doc = ) \n 
password = property ( lambda x : x . get ( ) , doc = ) \n 
realm = property ( lambda x : x . get ( ) , doc = ) \n 
nonce = property ( lambda x : x . get ( ) , doc = ) \n 
uri = property ( lambda x : x . get ( ) , doc = ) \n 
nc = property ( lambda x : x . get ( ) , doc = ) \n 
cnonce = property ( lambda x : x . get ( ) , doc = ) \n 
response = property ( lambda x : x . get ( ) , doc = ) \n 
opaque = property ( lambda x : x . get ( ) , doc = ) \n 
def qop ( self ) : \n 
def on_update ( header_set ) : \n 
~~~ if not header_set and in self : \n 
~~~ del self [ ] \n 
~~ elif header_set : \n 
~~~ self [ ] = header_set . to_header ( ) \n 
~~ ~~ return parse_set_header ( self . get ( ) , on_update ) \n 
~~ ~~ class WWWAuthenticate ( UpdateDictMixin , dict ) : \n 
_require_quoting = frozenset ( [ , , , ] ) \n 
def __init__ ( self , auth_type = None , values = None , on_update = None ) : \n 
if auth_type : \n 
~~~ self [ ] = auth_type \n 
~~ self . on_update = on_update \n 
~~ def set_basic ( self , realm = ) : \n 
dict . clear ( self ) \n 
dict . update ( self , { : , : realm } ) \n 
if self . on_update : \n 
~~ ~~ def set_digest ( self , realm , nonce , qop = ( , ) , opaque = None , \n 
algorithm = None , stale = False ) : \n 
d = { \n 
: realm , \n 
: nonce , \n 
: dump_header ( qop ) \n 
if stale : \n 
~~~ d [ ] = \n 
~~ if opaque is not None : \n 
~~~ d [ ] = opaque \n 
~~ if algorithm is not None : \n 
~~~ d [ ] = algorithm \n 
~~ dict . clear ( self ) \n 
dict . update ( self , d ) \n 
d = dict ( self ) \n 
auth_type = d . pop ( , None ) or \n 
return % ( auth_type . title ( ) , . join ( [ \n 
% ( key , quote_header_value ( value , \n 
allow_token = key not in self . _require_quoting ) ) \n 
for key , value in d . iteritems ( ) \n 
] ) ) \n 
~~ def auth_property ( name , doc = None ) : \n 
def _set_value ( self , value ) : \n 
~~~ self . pop ( name , None ) \n 
~~~ self [ name ] = str ( value ) \n 
~~ ~~ return property ( lambda x : x . get ( name ) , _set_value , doc = doc ) \n 
~~ def _set_property ( name , doc = None ) : \n 
~~~ def fget ( self ) : \n 
~~~ def on_update ( header_set ) : \n 
~~~ if not header_set and name in self : \n 
~~~ del self [ name ] \n 
~~~ self [ name ] = header_set . to_header ( ) \n 
~~ ~~ return parse_set_header ( self . get ( name ) , on_update ) \n 
~~ return property ( fget , doc = doc ) \n 
~~ type = auth_property ( , doc = ) \n 
realm = auth_property ( , doc = ) \n 
domain = _set_property ( , doc = ) \n 
nonce = auth_property ( , doc = ) \n 
opaque = auth_property ( , doc = ) \n 
qop = _set_property ( , doc = ) \n 
def _get_stale ( self ) : \n 
~~~ val = self . get ( ) \n 
if val is not None : \n 
~~~ return val . lower ( ) == \n 
~~ ~~ def _set_stale ( self , value ) : \n 
~~~ self . pop ( , None ) \n 
~~~ self [ ] = value and or \n 
~~ ~~ stale = property ( _get_stale , _set_stale , doc = ) \n 
del _get_stale , _set_stale \n 
auth_property = staticmethod ( auth_property ) \n 
del _set_property \n 
~~ class FileStorage ( object ) : \n 
def __init__ ( self , stream = None , filename = None , name = None , \n 
content_type = , content_length = - 1 , \n 
headers = None ) : \n 
~~~ self . name = name \n 
self . stream = stream or _empty_stream \n 
self . filename = filename or getattr ( stream , , None ) \n 
self . content_type = content_type \n 
self . content_length = content_length \n 
if headers is None : \n 
~~~ headers = Headers ( ) \n 
~~ self . headers = headers \n 
~~ def save ( self , dst , buffer_size = 16384 ) : \n 
from shutil import copyfileobj \n 
close_dst = False \n 
if isinstance ( dst , basestring ) : \n 
~~~ dst = file ( dst , ) \n 
close_dst = True \n 
~~~ copyfileobj ( self . stream , dst , buffer_size ) \n 
~~ finally : \n 
~~~ if close_dst : \n 
~~~ dst . close ( ) \n 
~~ ~~ ~~ def close ( self ) : \n 
~~~ self . stream . close ( ) \n 
~~ ~~ def __nonzero__ ( self ) : \n 
~~~ return bool ( self . filename ) \n 
~~ def __getattr__ ( self , name ) : \n 
~~~ return getattr ( self . stream , name ) \n 
~~~ return iter ( self . readline , ) \n 
self . filename , \n 
self . content_type \n 
~~ ~~ from werkzeug . http import dump_options_header , dump_header , generate_etag , quote_header_value , parse_set_header , unquote_etag \n 
from werkzeug . exceptions import BadRequest \n 
for _cls in MultiDict , OrderedMultiDict , CombinedMultiDict , Headers , EnvironHeaders : \n 
~~~ _cls . KeyError = BadRequest . wrap ( KeyError , _cls . __name__ + ) \n 
~~ del _cls \n 
from werkzeug . utils import import_string \n 
from kay . management . shell import ( \n 
rshell , shell , clear_datastore , create_user , \n 
from kay . management . runserver import runserver_passthru_argv \n 
from kay . management . startapp import startapp \n 
from kay . management . startapp import startproject \n 
from kay . management . appcfg import do_appcfg_passthru_argv \n 
from kay . management . bulkloader import ( \n 
do_bulkloader_passthru_argv , dump_all , restore_all , \n 
from kay . management . test import do_runtest \n 
from kay . management . preparse import do_preparse_bundle \n 
from kay . management . preparse import do_preparse_apps \n 
from kay . management . extract_messages import do_extract_messages \n 
from kay . management . add_translations import do_add_translations \n 
from kay . management . update_translations import do_update_translations \n 
from kay . management . compile_translations import do_compile_translations \n 
from kay . management . wxadmin import do_wxadmin \n 
from kay . management . compile_media import do_compile_media \n 
from kay . conf import settings \n 
action_dump_all = dump_all \n 
action_restore_all = restore_all \n 
action_shell = shell \n 
action_rshell = rshell \n 
action_startapp = startapp \n 
action_startproject = startproject \n 
action_test = do_runtest \n 
action_preparse_bundle = do_preparse_bundle \n 
action_preparse_apps = do_preparse_apps \n 
action_extract_messages = do_extract_messages \n 
action_add_translations = do_add_translations \n 
action_update_translations = do_update_translations \n 
action_compile_translations = do_compile_translations \n 
action_appcfg = do_appcfg_passthru_argv \n 
action_runserver = runserver_passthru_argv \n 
action_bulkloader = do_bulkloader_passthru_argv \n 
action_clear_datastore = clear_datastore \n 
action_create_user = create_user \n 
action_wxadmin = do_wxadmin \n 
action_compile_media = do_compile_media \n 
additional_actions = [ ] \n 
for app in settings . INSTALLED_APPS : \n 
~~~ appmod = import_string ( app ) \n 
if not os . path . exists ( os . path . join ( os . path . dirname ( appmod . __file__ ) , \n 
) ) : \n 
~~ management_mod = import_string ( "%s.management" % app ) \n 
for name , val in vars ( management_mod ) . iteritems ( ) : \n 
~~~ if name . startswith ( "action_" ) : \n 
~~~ locals ( ) [ name ] = getattr ( management_mod , name ) \n 
additional_actions . append ( name ) \n 
~~ ~~ ~~ except Exception , e : \n 
~~~ import traceback \n 
sys . stderr . write ( . join ( traceback . format_exception ( * ( sys . exc_info ( ) ) ) ) ) \n 
~~ ~~ __all__ = [ \n 
, , , \n 
, , , , \n 
, , , , , \n 
, , \n 
] + additional_actions \n 
def print_status ( msg ) : \n 
~~~ print ( msg ) \n 
sys . stdout . flush ( ) \n 
from kay . routing import ( \n 
ViewGroup , Rule \n 
view_groups = [ \n 
ViewGroup ( \n 
Rule ( , endpoint = , \n 
view = ( , ( ) , { } ) ) , \n 
view = ) , \n 
] \n 
from google . appengine . ext import db \n 
from kay . utils . forms import ValidationError \n 
from kay . utils . forms . modelform import ModelForm \n 
class MaxLengthValidator ( object ) : \n 
~~~ def __init__ ( self , length ) : \n 
~~~ self . length = length \n 
~~ def __call__ ( self , val ) : \n 
~~~ if len ( val ) > self . length : \n 
~~ ~~ class TestModel ( db . Model ) : \n 
~~~ number = db . IntegerProperty ( required = True ) \n 
data_field = db . StringProperty ( required = True , \n 
validator = MaxLengthValidator ( 20 ) ) \n 
is_active = db . BooleanProperty ( required = True ) \n 
string_list_field = db . StringListProperty ( required = True ) \n 
~~ class TestModel2 ( db . Model ) : \n 
~~ class TestModelForm ( ModelForm ) : \n 
~~~ csrf_protected = False \n 
class Meta ( ) : \n 
~~~ model = TestModel \n 
~~ def __init__ ( self , instance = None , initial = None ) : \n 
~~~ super ( TestModelForm , self ) . __init__ ( instance , initial ) \n 
self . string_list_field . min_size = 1 \n 
~~ ~~ class JsonTestModel ( db . Model ) : \n 
~~~ s = db . StringProperty ( ) \n 
i = db . IntegerProperty ( ) \n 
b = db . BooleanProperty ( ) \n 
l = db . StringListProperty ( ) \n 
r = db . ReferenceProperty ( ) \n 
~~ class ModelFormTestModel ( db . Model ) : \n 
~~~ s_name = db . StringProperty ( ) \n 
zip_code = db . StringProperty ( ) \n 
addr = db . StringProperty ( ) \n 
~~ class ModelFormTestForm ( ModelForm ) : \n 
class Meta : \n 
~~~ model = ModelFormTestModel \n 
fields = ( ) \n 
~~ ~~ class ValidationTestModel ( db . Model ) : \n 
~~~ slist = db . StringListProperty ( ) \n 
~~ class ValidationTestForm ( ModelForm ) : \n 
~~~ model = ValidationTestModel \n 
~~ def context_validate ( self , data ) : \n 
~~~ raise ValidationError ( "Error!" ) \n 
from os import path , listdir , mkdir \n 
def compile_file ( env , src_path , dst_path , encoding = , base_dir = ) : \n 
src_file = file ( src_path , ) \n 
~~~ source = src_file . read ( ) . decode ( encoding ) \n 
raise \n 
~~ src_file . close ( ) \n 
name = src_path . replace ( base_dir , ) \n 
raw = env . compile ( source , name = name , filename = name , raw = True ) \n 
dst_file = open ( dst_path , ) \n 
dst_file . write ( raw ) \n 
dst_file . close ( ) \n 
~~ def compile_dir ( env , src_path , dst_path , pattern = , \n 
encoding = , base_dir = None , \n 
negative_pattern = ) : \n 
if base_dir is None : \n 
~~~ base_dir = src_path \n 
~~ for filename in listdir ( src_path ) : \n 
~~~ if filename . startswith ( "." ) : \n 
~~ src_name = path . join ( src_path , filename ) \n 
dst_name = path . join ( dst_path , filename ) \n 
if path . isdir ( src_name ) : \n 
~~~ if not path . isdir ( dst_name ) : \n 
~~~ mkdir ( dst_name ) \n 
~~ compile_dir ( env , src_name , dst_name , encoding = encoding , \n 
base_dir = base_dir ) \n 
~~ elif path . isfile ( src_name ) and re . match ( pattern , filename ) and not re . match ( negative_pattern , filename ) : \n 
~~~ compile_file ( env , src_name , dst_name , encoding = encoding , \n 
~~ ~~ ~~ import logging \n 
from okcupyd . db import model , txn , with_txn \n 
log = logging . getLogger ( __name__ ) \n 
class UserAdapter ( object ) : \n 
~~~ def __init__ ( self , profile ) : \n 
~~~ self . profile = profile \n 
~~ def build ( self , session ) : \n 
~~~ found = model . User . query_no_txn ( session , model . User . handle == \n 
self . profile . username ) \n 
if found : \n 
~~~ return found [ 0 ] \n 
~~~ return model . User ( okc_id = self . profile . id , \n 
handle = self . profile . username , \n 
age = self . profile . age , \n 
location = self . profile . location ) \n 
~~ ~~ def get_no_txn ( self , session ) : \n 
~~~ return model . User . upsert_one_no_txn ( session , self . build ( session ) , \n 
id_key = ) \n 
~~ get = with_txn ( get_no_txn ) \n 
~~ class ThreadAdapter ( object ) : \n 
~~~ def __init__ ( self , thread ) : \n 
~~~ self . thread = thread \n 
~~ def _get_thread ( self , session ) : \n 
~~~ initiator = UserAdapter ( self . thread . initiator ) . get_no_txn ( session ) \n 
respondent = UserAdapter ( self . thread . respondent ) . get_no_txn ( session ) \n 
message_thread = model . MessageThread ( okc_id = self . thread . id , \n 
initiator = initiator , \n 
respondent = respondent ) \n 
return model . MessageThread . upsert_one_no_txn ( session , message_thread , \n 
~~ def _add_messages ( self , thread_model ) : \n 
~~~ existing_message_ids = set ( [ m . okc_id for m in thread_model . messages ] ) \n 
new_messages = [ message for message in self . thread . messages \n 
if message . id not in existing_message_ids ] \n 
new_message_models = [ ] \n 
for new_message in new_messages : \n 
~~~ from_initiator = thread_model . initiator . handle . lower ( ) == new_message . sender . username . lower ( ) \n 
sender , recipient = ( thread_model . initiator , \n 
thread_model . respondent ) if from_initiator else ( thread_model . respondent , \n 
thread_model . initiator ) \n 
new_message_model = model . Message ( okc_id = new_message . id , \n 
text = new_message . content , \n 
sender = sender , \n 
recipient = recipient , \n 
time_sent = new_message . time_sent ) \n 
new_message_models . append ( new_message_model ) \n 
thread_model . messages . append ( new_message_model ) \n 
~~ return new_message_models \n 
~~ def add_messages ( self ) : \n 
~~~ with txn ( ) as session : \n 
~~~ thread_model = model . MessageThread . find_no_txn ( session , \n 
self . thread . id , \n 
return self . _add_messages ( thread_model ) \n 
~~ ~~ def get_thread ( self ) : \n 
~~~ thread_model = self . _get_thread ( session ) \n 
return thread_model , self . _add_messages ( thread_model ) \n 
from invoke import task \n 
import IPython \n 
from okcupyd import db \n 
from okcupyd import util \n 
from okcupyd . db import mailbox , model \n 
from okcupyd . user import User \n 
@ task ( default = True ) \n 
def session ( ) : \n 
~~~ with db . txn ( ) as session : \n 
~~~ IPython . embed ( ) \n 
~~ ~~ @ task \n 
def reset ( ) : \n 
~~~ util . enable_logger ( __name__ ) \n 
log . info ( db . Base . metadata . bind ) \n 
db . Base . metadata . drop_all ( ) \n 
db . Base . metadata . create_all ( ) \n 
~~ @ task \n 
def sync ( ) : \n 
~~~ user = User ( ) \n 
mailbox . Sync ( user ) . all ( ) \n 
log . info ( model . Message . query ( model . User . okc_id == user . profile . id ) ) \n 
def make ( ) : \n 
user_model = model . User . from_profile ( user . profile ) \n 
user_model . upsert_model ( id_key = ) \n 
okcupyd_user = model . OKCupydUser ( user_id = user_model . id ) \n 
okcupyd_user . upsert_model ( id_key = ) \n 
return okcupyd_user \n 
~~ from . import util \n 
from okcupyd import User , photo \n 
@ util . use_cassette ( path = , \n 
match_on = util . match_on_no_body ) \n 
def test_photo_upload ( ) : \n 
~~~ uploader = photo . PhotoUploader ( ) \n 
upload_response_dict = uploader . upload_and_confirm ( ) \n 
assert int ( upload_response_dict [ ] ) > 0 \n 
~~ @ util . use_cassette ( path = , match_on = util . match_on_no_body ) \n 
def test_photo_delete ( ) : \n 
response_dict = user . photo . upload_and_confirm ( user . quickmatch ( ) . photo_infos [ 0 ] ) \n 
before_delete_photos = user . profile . photo_infos \n 
user . photo . delete ( response_dict [ ] ) \n 
user . profile . refresh ( ) \n 
assert len ( before_delete_photos ) - 1 == len ( user . profile . photo_infos ) \n 
~~ def test_make_photo_uri_from_https_link ( ) : \n 
~~~ photo_info = photo . Info . from_cdn_uri ( \n 
assert photo_info . id == 2254475731855279447 \n 
assert photo_info . thumb_nail_top == 21 \n 
~~ @ util . use_cassette \n 
def test_photo_info_upload ( vcr_live_sleep ) : \n 
response = user . photo . upload_and_confirm ( user . quickmatch ( ) . photo_infos [ 0 ] ) \n 
vcr_live_sleep ( 2 ) \n 
assert int ( response [ ] ) in [ pi . id for pi in user . profile . photo_infos ] \n 
~~ import sys , os , stat \n 
import pythoncom \n 
from win32com . shell import shell , shellcon \n 
import commctrl \n 
import winerror \n 
from win32com . server . util import wrap \n 
from pywintypes import IID \n 
IPersist_Methods = [ "GetClassID" ] \n 
IColumnProvider_Methods = IPersist_Methods + [ "Initialize" , "GetColumnInfo" , "GetItemData" ] \n 
class ColumnProvider : \n 
~~~ _reg_progid_ = "Python.ShellExtension.ColumnProvider" \n 
_reg_clsid_ = IID ( "{0F14101A-E05E-4070-BD54-83DFA58C3D68}" ) \n 
_com_interfaces_ = [ pythoncom . IID_IPersist , \n 
shell . IID_IColumnProvider , \n 
_public_methods_ = IColumnProvider_Methods \n 
def GetClassID ( self ) : \n 
~~~ return self . _reg_clsid_ \n 
~~ def Initialize ( self , colInit ) : \n 
~~~ flags , reserved , name = colInit \n 
~~ def GetColumnInfo ( self , index ) : \n 
~~~ if index in [ 0 , 1 ] : \n 
~~~ if index == 0 : \n 
~~~ ext = ".pyc" \n 
~~~ ext = ".pyo" \n 
col_info = ( \n 
20 , #cChars \n 
title , \n 
description ) \n 
return col_info \n 
~~ def GetItemData ( self , colid , colData ) : \n 
~~~ fmt_id , pid = colid \n 
fmt_id == self . _reg_clsid_ \n 
flags , attr , reserved , ext , name = colData \n 
if ext . lower ( ) not in [ ".py" , ".pyw" ] : \n 
~~ if pid == 0 : \n 
~~ check_file = os . path . splitext ( name ) [ 0 ] + ext \n 
~~~ st = os . stat ( check_file ) \n 
return st [ stat . ST_SIZE ] \n 
~~ except OSError : \n 
~~ ~~ ~~ def DllRegisterServer ( ) : \n 
~~~ import _winreg \n 
key = _winreg . CreateKey ( _winreg . HKEY_CLASSES_ROOT , \n 
"Folder\\\\ShellEx\\\\ColumnHandlers\\\\" + str ( ColumnProvider . _reg_clsid_ ) ) \n 
_winreg . SetValueEx ( key , None , 0 , _winreg . REG_SZ , ColumnProvider . _reg_desc_ ) \n 
~~ def DllUnregisterServer ( ) : \n 
~~~ key = _winreg . DeleteKey ( _winreg . HKEY_CLASSES_ROOT , \n 
~~ except WindowsError , details : \n 
~~~ import errno \n 
if details . errno != errno . ENOENT : \n 
~~~ raise \n 
~~~ from win32com . server import register \n 
register . UseCommandLine ( ColumnProvider , \n 
finalize_register = DllRegisterServer , \n 
finalize_unregister = DllUnregisterServer ) \n 
__all__ = [ \n 
from myapp import utils \n 
module_name = utils . getFinalName ( __name__ ) \n 
module = utils . getModule ( __name__ , subdomain = module_name ) \n 
import views \n 
import views . morepages #!/usr/bin/python2.4 \n 
__author__ = \n 
import urllib \n 
from pyactiveresource import connection \n 
from pyactiveresource import formats \n 
class Error ( Exception ) : \n 
~~ class FakeConnection ( object ) : \n 
def __init__ ( self , format = formats . XMLFormat ) : \n 
self . format = format \n 
self . _request_map = { } \n 
self . _debug_only = False \n 
~~ def _split_path ( self , path ) : \n 
path_only , query_string = urllib . splitquery ( path ) \n 
if query_string : \n 
~~~ query_dict = dict ( [ i . split ( ) for i in query_string . split ( ) ] ) \n 
~~~ query_dict = { } \n 
~~ return path_only , query_dict \n 
~~ def debug_only ( self , debug = True ) : \n 
~~~ self . _debug_only = debug \n 
~~ def respond_to ( self , method , path , headers , data , body , \n 
response_headers = None ) : \n 
path_only , query = self . _split_path ( path ) \n 
if response_headers is None : \n 
~~~ response_headers = { } \n 
~~ self . _request_map . setdefault ( method , [ ] ) . append ( \n 
( ( path_only , query , headers , data ) , ( body , response_headers ) ) ) \n 
~~ def _lookup_response ( self , method , path , headers , data ) : \n 
~~~ path_only , query = self . _split_path ( path ) \n 
for key , value in self . _request_map . get ( method , { } ) : \n 
~~~ if key == ( path_only , query , headers , data ) : \n 
~~~ response_body , response_headers = value \n 
return connection . Response ( 200 , response_body , response_headers ) \n 
~~ ~~ raise Error ( % \n 
( path , headers , data ) ) \n 
~~ def get ( self , path , headers = None ) : \n 
return self . format . decode ( \n 
self . _lookup_response ( , path , headers , None ) . body ) \n 
~~ def post ( self , path , headers = None , data = None ) : \n 
return self . _lookup_response ( , path , headers , data ) \n 
~~ def put ( self , path , headers = None , data = None ) : \n 
~~ def delete ( self , path , headers = None ) : \n 
return self . _lookup_response ( , path , headers , None ) \n 
~~ ~~ from trac . env import Environment \n 
from trac . attachment import Attachment \n 
from tracLib import * \n 
from ConfigParser import ConfigParser \n 
import tracLib \n 
import tracLib . timetracking \n 
class Client ( object ) : \n 
~~~ def __init__ ( self , env_path ) : \n 
~~~ self . env_path = env_path \n 
self . env = Environment ( env_path ) \n 
self . db_cnx = self . env . get_db_cnx ( ) \n 
self . _registered_users_logins = [ ] \n 
self . _timetracking_plugins = self . _get_timetracking_plugins ( ) \n 
~~ def _get_timetracking_plugins ( self ) : \n 
~~~ plugins = { } \n 
if tracLib . SUPPORT_TIME_TRACKING == : \n 
~~~ for plugin in tracLib . timetracking . plugins : \n 
~~~ plugin_name = plugin . get_name ( ) \n 
for com_name , com_enabled in self . env . _component_rules . items ( ) : \n 
~~~ if com_name . startswith ( plugin_name ) and com_enabled and plugin_name not in plugins : \n 
~~~ plugins [ plugin_name ] = plugin ( self . env ) \n 
~~ ~~ ~~ ~~ else : \n 
if plugin_name == tracLib . SUPPORT_TIME_TRACKING : \n 
break ; \n 
~~ ~~ ~~ for plugin_name in plugins . keys ( ) : \n 
~~ return plugins . values ( ) \n 
~~ def get_project_description ( self ) : \n 
~~~ return self . env . project_description \n 
~~ def get_users ( self ) : \n 
~~~ result = self . env . get_known_users ( ) \n 
trac_users = list ( [ ] ) \n 
for user in result : \n 
~~~ user_login = user [ 0 ] . lower ( ) \n 
if user_login in self . _registered_users_logins : \n 
~~ u = TracUser ( user_login ) \n 
u . email = user [ 2 ] \n 
trac_users . append ( u ) \n 
self . _registered_users_logins . append ( user_login ) \n 
~~ if not tracLib . ACCEPT_NON_AUTHORISED_USERS : \n 
~~~ return trac_users \n 
~~ user_fields = [ ( "owner" , "component" ) , ( "reporter" , "ticket" ) , ( "owner" , "ticket" ) , ( "author" , "attachment" ) ] \n 
first = True \n 
request = "" \n 
for column_name , table_name in user_fields : \n 
~~~ if first : \n 
~~~ first = False \n 
~~ cursor = self . db_cnx . cursor ( ) \n 
cursor . execute ( request ) \n 
for row in cursor : \n 
~~~ if row [ 0 ] not in self . _registered_users_logins : \n 
~~~ trac_user = self . _get_non_authorised_user ( row [ 0 ] ) \n 
if trac_user is not None : \n 
~~~ trac_users . append ( trac_user ) \n 
self . _registered_users_logins . append ( trac_user . name ) \n 
~~ ~~ ~~ return trac_users \n 
~~ def _get_non_authorised_user ( self , user_name ) : \n 
~~~ if user_name is None : \n 
~~ start = user_name . find ( "<" ) \n 
end = user_name . rfind ( ">" ) \n 
if ( start > - 1 ) and ( end > start + 1 ) : \n 
~~~ if user_name . find ( "@" , start , end ) > 0 : \n 
return user \n 
~~ ~~ return None \n 
~~ def _get_user_login ( self , user_name ) : \n 
~~ if user_name in self . _registered_users_logins : \n 
~~~ return user_name \n 
~~ user = self . _get_non_authorised_user ( user_name ) \n 
if ( user is None ) or ( user . name not in self . _registered_users_logins ) : \n 
~~ return user . name \n 
~~ def get_severities ( self ) : \n 
~~~ return self . _get_data_from_enum ( "severity" ) \n 
~~ def get_issue_types ( self ) : \n 
~~~ return self . _get_data_from_enum ( "ticket_type" ) \n 
~~ def get_issue_priorities ( self ) : \n 
~~~ return self . _get_data_from_enum ( "priority" ) \n 
~~ def get_issue_resolutions ( self ) : \n 
~~~ return [ TracResolution ( name ) for name in self . _get_data_from_enum ( "resolution" ) ] \n 
~~ def get_components ( self ) : \n 
~~~ cursor = self . db_cnx . cursor ( ) \n 
trac_components = list ( [ ] ) \n 
~~~ component = TracComponent ( row [ 0 ] ) \n 
component . owner = self . _get_user_login ( component . owner ) \n 
if row [ 2 ] is not None : \n 
~~~ component . description = row [ 2 ] \n 
~~ trac_components . append ( component ) \n 
~~ return trac_components \n 
~~ def get_versions ( self ) : \n 
trac_versions = list ( [ ] ) \n 
~~~ version = TracVersion ( row [ 0 ] ) \n 
if row [ 1 ] : \n 
~~~ version . time = to_unix_time ( row [ 1 ] ) \n 
~~ if row [ 2 ] is not None : \n 
~~~ version . description = row [ 2 ] \n 
~~ trac_versions . append ( version ) \n 
~~ return trac_versions \n 
~~ def get_issues ( self ) : \n 
trac_issues = list ( [ ] ) \n 
~~~ issue = TracIssue ( row [ 0 ] ) \n 
issue . time = to_unix_time ( row [ 2 ] ) \n 
issue . changetime = to_unix_time ( row [ 3 ] ) \n 
issue . reporter = self . _get_user_login ( row [ 8 ] ) \n 
if row [ 9 ] is not None : \n 
~~~ cc = row [ 9 ] . split ( "," ) \n 
for c in cc : \n 
~~~ if len ( c ) > 0 : \n 
~~~ cc_name = self . _get_user_login ( c . strip ( ) ) \n 
if cc_name is not None : \n 
~~~ issue . cc . add ( cc_name ) \n 
~~ ~~ ~~ ~~ issue . summary = row [ 13 ] \n 
issue . description = row [ 14 ] \n 
issue . custom_fields [ "Type" ] = row [ 1 ] \n 
issue . custom_fields [ "Component" ] = row [ 4 ] \n 
issue . custom_fields [ "Severity" ] = row [ 5 ] \n 
issue . custom_fields [ "Priority" ] = row [ 6 ] \n 
issue . custom_fields [ "Owner" ] = self . _get_user_login ( row [ 7 ] ) \n 
issue . custom_fields [ "Version" ] = row [ 10 ] \n 
issue . custom_fields [ "Status" ] = row [ 11 ] \n 
issue . custom_fields [ "Resolution" ] = row [ 12 ] \n 
if row [ 15 ] is not None : \n 
~~~ keywords = row [ 15 ] . rsplit ( "," ) \n 
for kw in keywords : \n 
~~~ if len ( kw ) > 0 : \n 
~~~ issue . keywords . add ( kw . strip ( ) ) \n 
~~ ~~ ~~ custom_field_cursor = self . db_cnx . cursor ( ) \n 
for cf in custom_field_cursor : \n 
~~~ issue . custom_fields [ cf [ 0 ] . capitalize ( ) ] = cf [ 1 ] \n 
~~ attachment_cursor = self . db_cnx . cursor ( ) \n 
for elem in attachment_cursor : \n 
~~~ at = TracAttachment ( Attachment . _get_path ( self . env . path , , str ( issue . id ) , elem [ 0 ] ) ) \n 
at . name = elem [ 0 ] \n 
at . size = elem [ 1 ] \n 
at . time = to_unix_time ( elem [ 2 ] ) \n 
at . description = elem [ 3 ] \n 
at . author_name = elem [ 4 ] \n 
issue . attachment . add ( at ) \n 
~~ trac_issues . append ( issue ) \n 
change_cursor = self . db_cnx . cursor ( ) \n 
for elem in change_cursor : \n 
~~~ if ( elem [ 2 ] is None ) or ( not len ( elem [ 2 ] . lstrip ( ) ) ) : \n 
~~ comment = TracComment ( to_unix_time ( elem [ 0 ] ) ) \n 
comment . author = str ( elem [ 1 ] ) \n 
comment . content = unicode ( elem [ 2 ] ) \n 
comment . id = elem [ 3 ] \n 
issue . comments . add ( comment ) \n 
~~ for ttp in self . _timetracking_plugins : \n 
~~~ issue . workitems . update ( set ( ttp [ row [ 0 ] ] ) ) \n 
~~ ~~ return trac_issues \n 
~~ def get_custom_fields_declared ( self ) : \n 
~~~ ini_file_path = self . env_path + "/conf/trac.ini" \n 
parser = ConfigParser ( ) \n 
parser . read ( ini_file_path ) \n 
if not ( "ticket-custom" in parser . sections ( ) ) : \n 
~~~ return set ( [ ] ) \n 
~~ result = parser . items ( "ticket-custom" ) \n 
items = dict ( [ ] ) \n 
for elem in result : \n 
~~~ items [ elem [ 0 ] ] = elem [ 1 ] \n 
~~ keys = items . keys ( ) \n 
custom_fields = list ( [ ] ) \n 
for k in keys : \n 
~~~ if not ( "." in k ) : \n 
~~~ field = TracCustomFieldDeclaration ( k . capitalize ( ) ) \n 
field . type = items [ k ] \n 
options_key = k + ".options" \n 
if options_key in items : \n 
~~~ opts_str = items [ options_key ] \n 
opts = opts_str . rsplit ( "|" ) \n 
for o in opts : \n 
~~~ field . options . append ( o ) \n 
~~ ~~ value_key = k + ".value" \n 
if value_key in items : \n 
~~~ field . value = items [ value_key ] \n 
~~ label_key = k + ".label" \n 
if label_key in items : \n 
~~~ field . label = items [ label_key ] \n 
~~ custom_fields . append ( field ) \n 
~~ ~~ return custom_fields \n 
~~ def _get_data_from_enum ( self , type_name ) : \n 
return [ row [ 0 ] for row in cursor ] \n 
~~ ~~ 
